<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/TR/REC-html40" xmlns:o = 
"urn:schemas-microsoft-com:office:office" xmlns:dt = 
"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"><HEAD><META content="IE=5.0000" 
http-equiv="X-UA-Compatible">

<META content="text/html; charset=utf-8" http-equiv=Content-Type>
<META name=ProgId content=OneNote.File>
<META name=GENERATOR content="MSHTML 11.00.10570.1001"><LINK id=Main-File 
rel=Main-File href="Lecturenote_v3.htm"><LINK rel=File-List 
href="Lecturenote_v3_files/filelist.xml"></HEAD>
<BODY lang=en-US style="FONT-SIZE: 11pt; FONT-FAMILY: Roboto">
<DIV style="DIRECTION: ltr">
<DIV style="WIDTH: 11.144in; MARGIN-TOP: 0in; DIRECTION: ltr; MARGIN-LEFT: 0in">
<DIV 
style="WIDTH: 2.375in; MARGIN-TOP: 0in; DIRECTION: ltr; MARGIN-LEFT: 0.831in">
<P style='FONT-SIZE: 20pt; FONT-FAMILY: "Calibri Light"; MARGIN: 0in'>Lecture 
note_v3</P></DIV>
<DIV 
style="WIDTH: 1.773in; MARGIN-TOP: 0.038in; DIRECTION: ltr; MARGIN-LEFT: 0.831in">
<P lang=zh-CN style="FONT-SIZE: 10pt; COLOR: #767676; MARGIN: 0in"><SPAN 
style="FONT-FAMILY: Calibri">2019</SPAN><SPAN 
style='FONT-FAMILY: "Microsoft YaHei"'>年</SPAN><SPAN 
style="FONT-FAMILY: Calibri">12</SPAN><SPAN 
style='FONT-FAMILY: "Microsoft YaHei"'>月</SPAN><SPAN 
style="FONT-FAMILY: Calibri">24</SPAN><SPAN 
style='FONT-FAMILY: "Microsoft YaHei"'>日</SPAN></P>
<P lang=zh-CN 
style="FONT-SIZE: 10pt; FONT-FAMILY: Calibri; COLOR: #767676; MARGIN: 0in">10:05</P></DIV>
<DIV 
style="WIDTH: 11.144in; MARGIN-TOP: 0.861in; DIRECTION: ltr; MARGIN-LEFT: 0in"><NOBR><IMG 
alt="Protocols define the format, order of message send and received among network entities, and actions taken on message transmission.&#13;&#10;Why does standard is important for protocol? &#13;&#10;End hosts: The things that connected to internet, i.e. PC, server, wireless laptop, smartphone&#13;&#10;Communication links: i.e. Fiber, copper wire, radio, satellite.&#13;&#10;packet switch: i.e. Router and switches&#13;&#10;Infrastructure:&#13;&#10;Network edge: refers to device at end-system, such as laptop, iPad, cell phone&#13;&#10;Network core: Interconnected Routers, network of network, the backbone of network structure&#13;&#10;Access net: the connection between edge and core, e.g.Ethernet, WIFI network, celler tower. &#13;&#10;End Systems: the host that run application/program, e.g. web, email&#13;&#10;Untitled picture.png 5 &#10;4 &#10;3 &#10;2 &#10;Layer Name &#10;Application &#10;Transport &#10;Network &#10;Data Link &#10;Physical &#10;Protocol &#10;H-rrp, SMTP, &#10;etc.. &#10;TCP/UDP &#10;Ethernet, Wi-Fi &#10;10 Base T, &#10;802.11 &#10;Protocol &#10;Data Unit &#10;Messages &#10;Segment &#10;Datagram &#10;Addressing &#10;n/a &#10;Port &#10;IP address &#10;MAC Address &#10;Frames &#10;Bits &#10;n/a &#13;&#10;The TCP/IP Five-layer network model:&#13;&#10;1/5 Lecture 1(Network edge, Network, core, access net, end system==end system)&#13;&#10;Congestion can happen, packet might get dropped,  retransmission can happen&#13;&#10;Host&#13;&#10;Router&#13;&#10;Store and forward&#13;&#10;Queuing&#13;&#10;Good for bursty data&#13;&#10;Resource share&#13;&#10;Simpler, and cheaper to setup&#13;&#10;What are the advantage of packet switching?&#13;&#10;Possible to loss packet if congestion is heavy&#13;&#10;What are the dis-advantage of packet switching?&#13;&#10;Packet switching&#13;&#10;An very old communication system for telephone network, an physical electrical connection need to be established between two host.&#13;&#10;End-to-End resourced reserved&#13;&#10;Dedicated resource, so no sharing resources&#13;&#10;Performance guaranteed&#13;&#10;Circuit switching (old one)&#13;&#10;1/8 Lecture2  (Packet switching Vs Circuit switching)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCB4D(1).tmp" width=1070 height=960><BR><IMG 
alt="Performance guaranteed&#13;&#10;Common in traditional telephone network&#13;&#10;Guaranteed performance(throughput, delay)&#13;&#10;What are the advantage of circuit switching?&#13;&#10;Complex and expensive to setup&#13;&#10;What are the dis-advantage of circuit switching?&#13;&#10;CS has explicity set up phase but PS doesn't. &#13;&#10;CS reserved resources, and each &#13;&#10;Allow resources sharing&#13;&#10;Simpler to implement, and lower cost&#13;&#10;Why do we choose Packet switch over Circuit switch?&#13;&#10;Packet switching Vs Circuit switch&#13;&#10;Throughput(吞吐量)--How much data you can send in certain time? like speed/velocity(bit/sec) = Traffic load(bits)/Time(s). Like watching video in Youtube, Netflix.&#13;&#10;Latency/Delay-how long does it take a bit to send from one end to the other?&#13;&#10;Reliability--no data loss&#13;&#10;Security--no hacking &#13;&#10;Privacy--GDPR&#13;&#10;Censorship--not under government's monitor&#13;&#10;Eco-friendly&#13;&#10;Inexpensive&#13;&#10;Easy to upgrade or reconfigure&#13;&#10;What to design a good protocol? Any performance metric&#13;&#10;&#13;&#10;Concept: Bottleneck transmission rate, measures the number of useful rate(bits/sec) delivered at the receiver, and is different from but related to the individual link data rates&#13;&#10;Instantaneous: rate at given point in time&#13;&#10;Average: rate over longer period of time &#13;&#10;Bottleneck link: The throughput of a transfer is limited by the link with the slowest throughput along the path - bottleneck link. (you cannot pump data faster than the rate of the slowest link) &#13;&#10;Throughput (&quot;Fluid model&quot;) -- The amount of data you  can pump to link at certain time, in unit bps(bit/sec).&#13;&#10;Untitled picture.png (c) (2 points) What is the queuing delay of this link if there is queue Of 10 packets, created due to cross traffic? &#10;Assume bit packets as before. &#13;&#10;Queueing delay(排队延迟): Size of packets(bits)/throughtput(bit/sec), time waiting at output link for transmission, depends on congestion level of router&#13;&#10;Processing delay(处理延迟): Time taking for checking bit error, determine at output link&#13;&#10;Untitled picture.png (b) (2 points) What is the transmission delay Of the link. i.e., the time &#10;packet are sent? Assume a packet is 1000 bits. &#10;een When the first and last bits of a &#13;&#10;Transmission delay(传输延迟): L(bits)/R(bps), Time takes to send the packet, depends on packet length/size, and link bandwidth&#13;&#10;Delay (four source: nodal processing节点处理, queueing delay, propagation delay)&#13;&#10;Performance&#13;&#10;1/10, Lecture 3 (Delay, throughout, reliability)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCB6F(1).tmp" width=1070 height=960><BR><IMG 
alt='Untitled picture.png (b) (2 points) What is the transmission delay Of the link. i.e., the time &#10;packet are sent? Assume a packet is 1000 bits. &#10;een When the first and last bits of a &#13;&#10;Untitled picture.png transmis &#10;on &#10;"—propagation —e &#10;hop ¯ &#10;nodal &#10;processing queueing &#10;trans prop &#10;queue &#10;proc &#13;&#10;Propagation delay(传播延迟): d(m)/s(m/s).That is, the bits have to propagate/transmit at the speed of waves/light in the transmission medium to reach the other end. This delay depends on the length of the wire, and is usually only significant for long distance links. Ex: So a radio wave takes 1 microsec for a distance of 300 metres. Speed of light in copper is around 2*10^8 metres. So it takes 10 nanosec to travel a 2 meter long wire.&#13;&#10;Hop: "Hop" is just a regular english word (meaning "to jump"), and not an acronym. In networking, hop refers to how many "jumps" a packet has to make before reaching its destination. In our case, each time a packet encounters a router it is considered as a hop. The hop delay I was referring to in class, is basically the delay the packet experiences between one hop to the next hop.   https://en.wikipedia.org/wiki/Hop_(networking)&#13;&#10;Buffer size has limited capacity&#13;&#10;Packet may be dropped if buffer is full&#13;&#10;The lost packet may be retransmitted&#13;&#10;Packet might take different path and might arrive out-of-order&#13;&#10;Reliability:&#13;&#10;&#13;&#10;Analogy: (CA)(Menlo park)(Hacker way)(1) <==> 127.0.10.100&#13;&#10;Routing: process of determining the end-to-end path from source to destination&#13;&#10;The responsibility of IP protocal: Router follow a routing algorithm for forwarding packet, and each packet includes "address" of its destination&#13;&#10;The internet protocol(IP)&#13;&#10;IP Performance: provide no guarantees &#13;&#10;Connecting several existing network by using routers&#13;&#10;Function of routes: forward data from one network to the next&#13;&#10;End-to-end principle&#13;&#10;Original goal for the internet: design for general usage.&#13;&#10;Application: programmed in the host, support network application&#13;&#10;Transport: provide realizable data transfer/communication&#13;&#10;Routing/Network layer: provide source-to-destination end systems communication, e.g. connecting the existing network, receive/send data between network, deciding routing path.&#13;&#10;Link layer: provide the reliable transfer/communication between neighboring network nodes, e.g. router and end-system&#13;&#10;Physical layer: provide bitwise signal communication, e.g. converting the bits to voltage or EM wave for signal transmission&#13;&#10;Layering in the Internet&#13;&#10;Easy development for complex application&#13;&#10;&#13;&#10;Easy maintenance, and system&#13;&#10;Why do we want this layering structure design?&#13;&#10;1/13 Lectures 4: &#13;&#10;' 
src="Lecture%20note_v3_files/mhtCB91(1).tmp" width=1070 height=960><BR><IMG 
alt="&#13;&#10;&#13;&#10;1/15 Lecture 5: (Encapsulation, responsibility and application example for each layer)&#13;&#10;Solution: includet both IP address and a process Identifier(aka Port number) in packet&#13;&#10;Untitled picture.png destination &#10;switch &#10;source &#10;a licatio &#10;transpo &#10;network &#10;link &#10;ph sical &#10;switch &#10;hysical &#10;router &#10;link &#10;physical &#10;router &#10;link &#10;physical &#10;hysical &#10;(IP address) &#10;tran &#10;ne &#10;h &#10;port &#10;Ork &#10;'cal &#13;&#10;Addressing process on Hosts: There may have multiple process/application running on Host.&#13;&#10;preparing the package --> Fillout the paybill --> Send to FedEx office --> Send to sorting facility --> Loading dock --> &#13;&#10;8755273778cfd7275b95a1485976201.jpg ررار -راء» &#10;م &#10;عراب»»A &#10;ما ردع éL &#13;&#10;Analogy of OSI in Delivering system: transferring a large amount of data from LA to boston&#13;&#10;Untitled picture.png source &#10;a licatio &#10;transpo &#10;network &#10;ph sical &#10;switch &#10;hysical &#10;router &#10;ne r &#10;link &#10;physical &#10;router &#10;link &#10;physical &#10;switch &#10;hysical &#10;destination &#10;lication &#10;network &#10;link &#10;h sical &#13;&#10;It's a symmetrical delivering procedure&#13;&#10;payload: the actually data  we want to send (not include any header, or meta data)&#13;&#10;M is the payload of segment, stands for message&#13;&#10;H_t, H_n, H_i are the header for each layer&#13;&#10;header tell the information about the packet, like ID, meta information&#13;&#10;link --> physical: converting bits data to certain signal or wave&#13;&#10;Encapsulation&#13;&#10;//Chapter 2 Network application&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCBC3(1).tmp" width=1070 height=960><BR><IMG 
alt="link --> physical: converting bits data to certain signal or wave&#13;&#10;implement the software on different end system&#13;&#10;Communicate over the network&#13;&#10;Primary responsibility: &#13;&#10;What functions and communication operations must the application perform? E.g E-mail, Web app, Ride-sharing?&#13;&#10;What type of transport layer services does it requires? E.g. TCP/UDP?&#13;&#10;How can we provide those transport layer services to the application? e.g. Sockey API&#13;&#10;Three key questions to ask (When creating a new application):&#13;&#10;Untitled picture.png request line &#10;(GET, POST, &#10;Hmp/l. &#10;HEAD comnunds) &#10;header , &#10;lines &#10;carriage return, &#10;feed at start &#10;of line indicates &#10;,uEE-E &#10;end of lines &#10;HTTP request message &#10;Status line &#10;(protocol &#10;Status code &#10;Status phrase) &#10;data, e_g_, &#10;requested &#10;HTML file &#10;HTTP/I.1 200 &#10;Date: 26 sep 2010 &#10;rue, 30 oce 200' &#10;A&amp;pe - : bytes &#10;26 S 2 &#10;Kæp—AIi n &#10;— Type ; S 9— &#10;data data data &#10;HTTP response message &#13;&#10;Example of HTTP request/response message&#13;&#10;&#13;&#10;Application layer protocol: HTTP&#13;&#10;Network application&#13;&#10;Server: Always on, has permanent IP address&#13;&#10;Clients: communicate with server whenever needed&#13;&#10;Concept: Applications are typically structured as cliend-server applications. When you browse the web, your browser is the &quot;client&quot; and the web server is the &quot;server&quot;. The server is always on, waiting for clients, Clients approach the server when needed. Server are maintained in data center or server farms.&#13;&#10;Client-Server &#13;&#10;Not always-on server, each end-system directly communicate with each other&#13;&#10;Scalability: New peers/user bring new service capacity&#13;&#10;Scalability: less load on server. New peers can bring new service to network, as well as demand&#13;&#10;faster download: as the number of client increase, &#13;&#10;Anonymity&#13;&#10;More robust&#13;&#10;Advantage: &#13;&#10;Peer-to-peer&#13;&#10;Network Application Architecture&#13;&#10;1/17, Lecture6: (network application layer, TCP vs UDP); 1/22, Lectuer7: (Socket API)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCBE5(1).tmp" width=1070 height=960><BR><IMG 
alt='More robust&#13;&#10;Some terminology: "peer churn", churn rate, BitTorrent&#13;&#10;Two reason for how file sharing system work:  a spawn of user has desire on single file, or a user have the entire file and want to help others&#13;&#10;no loss of data&#13;&#10;Data integrity&#13;&#10;Elastic traffic and Inelastic traffic&#13;&#10;low delay&#13;&#10;Latency&#13;&#10;large throughput (amount of data allow to transfer)&#13;&#10;Throughput&#13;&#10;Good Encryption&#13;&#10;Security&#13;&#10;Transport layer service&#13;&#10;Connection-oriented: a connection oriented protocol, use Three-Handshake connection&#13;&#10;Reliability: reliable delivery of data, but slower in speed&#13;&#10;Untitled picture &#13;&#10;Flow control: sender/receiver speed matching&#13;&#10;Congestion-control mechanism: breaks long messages into shorter segments, so that a source throttles its transmission rate when the network is congested.&#13;&#10;TCP(Transmission control protocol): TCP provides connection-oriented reliability for in-order delivery of a byte stream, important for application like E-mail, Terminal Access, Web and file transfer, which need reliable data transfer. &#13;&#10;Connectionless protocol (无连接协议): No connection need to build for data transferring&#13;&#10;No reliability, no security. However, small overhead(header size), low latency(No congestion control), so good for real-time communication software&#13;&#10;UDP (User datagram protocol): UDP just delivers message without any reliability promises, no flow control, no congestion control  USP is preffered by some real time application, such as Internet telephony, Real-time video conferencing, audio/video streaming(视频数据流), which can tolerate some loss . &#13;&#10;Two types for two transport services:&#13;&#10;Untitled picture.png Application &#10;E-mail &#10;Web &#10;File transfer &#10;Streaming multimedia &#10;Internet telephony &#10;Application layer protocol &#10;Simple Mail Transfer Protocol (SMTP) &#10;Hypertext Transfer Protocol (HTTP) &#10;File Transfer Protocol (FTP) &#10;HTTP (e.g., yourube), &#10;Real-time Transport Protocol (RTP) &#10;Session Initiation Protocol (SIP), RTP, &#10;proprietary (e.g., Skype) &#10;Underlying transport &#10;protocol &#10;TCP &#10;TCP &#10;TCP &#10;TCP &#10;UDP &#10;TCP or UDP &#13;&#10;Real world example:&#13;&#10;�HYPERLINK "https://www.cse.iitb.ac.in/~cs348m/notes/lec04.txt"Transport layer protocal&#13;&#10;' 
src="Lecture%20note_v3_files/mhtCC07(1).tmp" width=1070 height=960><BR><IMG 
alt='Untitled picture.png Application &#10;E-mail &#10;Web &#10;File transfer &#10;Streaming multimedia &#10;Internet telephony &#10;Application layer protocol &#10;Simple Mail Transfer Protocol (SMTP) &#10;Hypertext Transfer Protocol (HTTP) &#10;File Transfer Protocol (FTP) &#10;HTTP (e.g., yourube), &#10;Real-time Transport Protocol (RTP) &#10;Session Initiation Protocol (SIP), RTP, &#10;proprietary (e.g., Skype) &#10;Underlying transport &#10;protocol &#10;TCP &#10;TCP &#10;TCP &#10;TCP &#10;UDP &#10;TCP or UDP &#13;&#10;Untitled picture.png Transmission Control Protocol (TCP) &#10;• Data integrity &#10;• Reliable &#10;• In-order delivery &#10;• Flow control &#10;• Congestion control &#10;• Slower than UDP &#10;• Setup required between client &#10;and server &#10;User Datagram Protocol (UDP) &#10;• "No frills" transport protocol &#10;• Best-effort service &#13;&#10;Comparing TCP Vs UDP&#13;&#10;Application layer&#13;&#10;Transport layer&#13;&#10;Routing/Network layer&#13;&#10;Linking layer&#13;&#10;Physical layer&#13;&#10;What are the five layers in the Internet Protocol stack?&#13;&#10;Application layer: Implement the software in the end-system&#13;&#10;Transport layer: provide reliable data transfer&#13;&#10;Network/Routing layer: decide the best path to send the packets&#13;&#10;Linking layer: provide reliability in sending packet to next "hop" (from one router/endhost to the next, along the path found by network/routing layer)&#13;&#10;Untitled picture.png Application layer: streaming a movie on Netflix &#10;Tran.ort layer: establishes reliable end-to-end connection between source &#10;and Netflix server &#10;Network layer: uses source, destination addresses from transport layer to find &#10;path on which to send packets on &#10;Link layer: prepare actual packet to send on next hop, depending on &#10;nature of network &#10;Physical layer: con•ært bits to voltages or EM waves and &#10;transmit on medium &#13;&#10;Physical layer: converting bit data to voltage or EM wave&#13;&#10;What are the principal responsibilities of each of these layers?&#13;&#10;List five layers of Internet &#13;&#10;HW01&#13;&#10;' 
src="Lecture%20note_v3_files/mhtCC2A(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Application layer: streaming a movie on Netflix &#10;Tran.ort layer: establishes reliable end-to-end connection between source &#10;and Netflix server &#10;Network layer: uses source, destination addresses from transport layer to find &#10;path on which to send packets on &#10;Link layer: prepare actual packet to send on next hop, depending on &#10;nature of network &#10;Physical layer: con•ært bits to voltages or EM waves and &#10;transmit on medium &#13;&#10;HTTP is for web application, SMTP is for email transfer, FTP is for file transfer, telnet is outdated cliend-server protocol.&#13;&#10;Application layer: HTTP(Run on TCP), SMTP, FTP, Telnet, DNS(run on UDP)&#13;&#10;Transport layer: TCP, UDP&#13;&#10;Network/Routing layer: IP&#13;&#10;Linking layer: Wifi, ethernet&#13;&#10;Physical layer: radio tower, fiber optic, modem, Electromagnetic wave&#13;&#10;Give an example of a protocol, application, or link technology at each layer?&#13;&#10;&#13;&#10;&#13;&#10;Concept of socket: Application developers use socket interface to send and receive &quot;message&quot;. (e.g., client sends server a message requesting a web page). Think of sockets as post boxes, and application layer delivers the message (e.g. GET or POST) from mail boxes. The transport layer handles how the message is delivered, much like how the postal system handles how mail is delivered.&#13;&#10;Purpose: learn how to build client/server application that communicate using sockets&#13;&#10;Socket: door between application process and end-end-transport protocol&#13;&#10;Analogy: Socket == Door&#13;&#10;Untitled picture.png so &#10;pollonu &#10;Jad01aAap dde &#10;Áq pa110J1uoo &#10;su a &#10;ssaoo &#10;uoqeu &#10;aayoos &#10;le3sA4d &#10;de &#13;&#10;Socket programming&#13;&#10;Motivation: If several sockets open on a machine, how do we know which socket a message is destined to? (Note: IP address gives the information of which machine should be deliver to, but doesn't help beyond that.) ==> Answer: Port numbers.&#13;&#10;IP address: for identifying which machine(End host) the packet should be send to. (32 bit for IPV4, and 128 bit for IPV6)&#13;&#10;Also specifies the socket address&#13;&#10;why they have certain port number?  ==> Used pretty often&#13;&#10;Common port number: HTTP--80, mail--25&#13;&#10;Size of port number: 16 bit&#13;&#10;In server side, there can be multiple client want to reach it. &#13;&#10;Port number: 16-bit identifier that uniquely identifies the several open sockets on a machine. (because there can be multiple process running on an computer).&#13;&#10;Addressing processes on Hosts&#13;&#10;Socket API&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCC4C(1).tmp" width=1070 height=960><BR><IMG 
alt="In server side, there can be multiple client want to reach it. &#13;&#10;Binding: bind the port number to UDP socket. so the message that has port number 12000 will be delivered to specific socket in the server.&#13;&#10;No handshaking before sending data&#13;&#10;Sender attaches IP address and port # to each packet&#13;&#10;Rcvr extracts sender IP addresses at port# from received packet&#13;&#10;UDP: provide unreliable transfer of groups of bytes(&quot;datagrams&quot;) between client and server&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;J UPP socket &#10;Network &#13;&#10;&#13;&#10;Visualization of procedure:&#13;&#10;Untitled picture.png client &#10;include Python's socket &#10;library &#10;create IJDP socket &#10;attach server name, port to &#10;message; send into socket &#10;&quot;hello &#10;Python UDP Client &#10;from socket import * &#10;clientSocket — &#10;clientSocket. close() &#10;server &#10;121.3.25.62 &#10;port: 12000 &#10;- SOCK_DGRAM) &#10;clientSocket . sendto( &quot;hello! encode ( ) , &#10;(&quot;121.3.25.62&quot;, &#10;12090)) &#13;&#10;Overall process&#13;&#10;get_sock comment, &#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;Detail explanation:&#13;&#10;UDP Client: Create socket ==> attach (ip address and port number) to each encoded packet ==> send to server ==> and close it&#13;&#10;Socket programming with UDP&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCC7E(1).tmp" width=1070 height=960><BR><IMG 
alt="get_sock comment, &#13;&#10;AF_INET, create the socket for over communication. ip refer , &#13;&#10;SOCK_DGRAM: specifies we are using UPD protocol&#13;&#10;first is the message that you want to send, must convert to binary code&#13;&#10;Second is the server ip and port number&#13;&#10;Untitled picture.png attach server name, port to &#10;message; send into socket &#10;clientSocket. ! encode( ) , &#10;(&quot;121.3.25.62&quot;, &#10;12øee)) &#13;&#10;Untitled picture.png client &#10;bind socket to local port &#10;number 12000 &#10;read from UDP socket into &#10;message, getting client's &#10;address (IP and port) &#10;&quot;hello &#10;Python UDP Server &#10;from socket import * &#10;server &#10;121.3.25.62 &#10;port: 12000 &#10;—e &#10;- SOCK_DGRAM) &#10;serverSocket — &#10;serverSocket . bind ( , &#10;12090) ) &#10;clientAddress = serverSocket. recvfrom(2Ø48) &#10;message, &#10;message = message. decode() &#13;&#10;Client reads a line of characters (data) from its keyboard and sends the data to the server. &#13;&#10;The server receives the data and converts characters to uppercase.&#13;&#10;The server sends the modified data to the client&#13;&#10;The client receives the modified data and displays the line on its screen.&#13;&#10;Note: You might need a while loop to keep this process going&#13;&#10;Overall operation&#13;&#10;binding the port number to a socket on the server&#13;&#10;ip address also can bind to address, so only the source ip message will be received&#13;&#10;Untitled picture.png bind socket to local port &#10;number 12000 &#10;serverSocket. bind ( &#10;, 12€eø)) &#13;&#10;recvfrom: received message from..&#13;&#10;2048: a safe number, the size of buffer, if the message greater than 2048 byte will be truncated. If the server is not running, the package will be lost.&#13;&#10;ClientAddress give us the address of client, so Server can send another message back to client as well&#13;&#10;Untitled picture.png read from UDP socket into &#10;message, getting client's &#10;address (IP and port) &#10;message, &#10;message &#10;clientAddress = serverSocket. recvfrom(2Ø48) &#10;= message. decode() &#13;&#10;Detail explanation:&#13;&#10;create a socket: socket(AF_INET, SOCK_DGRAM)&#13;&#10;bind ip and port#: sock.bind(( &quot;121.3.25.62&quot;, 12000))&#13;&#10;send message: sock.send(&quot;hello&quot;.encode())&#13;&#10;Summary: &#13;&#10; UDP Server: create socket ==> bind port number to socket ==> recv message and decode it&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCCA0(1).tmp" width=1070 height=960><BR><IMG 
alt="send message: sock.send(&quot;hello&quot;.encode())&#13;&#10;recv message: sock.recvfrom(2048)&#13;&#10;Untitled picture.png 4 &#10;6 &#10;7 &#10;8 &#10;9 &#10;10 &#10;11 &#10;12 &#10;13 &#10;14 &#10;15 &#10;16 &#10;17 &#10;18 &#10;19 &#10;20 &#10;21 &#10;22 &#10;23 &#10;24 &#10;25 &#10;26 &#10;27 &#10;28 &#10;29 &#10;30 &#10;31 &#10;32 &#10;serv name &#10;serv_port &#10;&quot;127.e.ø.1&quot; &#10;12eøé &#10;# Create a UDP socket &#10;client _ socket socket(AF INET , &#10;# Set the timeout for 1 second &#10;client _ socket . settimeout ( 1) &#10;# Send 10 pings to the server &#10;in range(1Ø): &#10;for &#10;try: &#10;&quot;Ping &quot; + &#10;msg &#10;# print(msg) &#10;str(i) &#10;SOCK_DGRAM) &#10;time. ctime() &#10;# Set the timmer: &#10;start time. time() &#10;# Send the ping message to server &#10;client _ socket. sendto(msg. encode(), (serv name, serv_port)) &#10;# Wait up to one sec for a reply; If reply is received, print the response message &#10;client_socket. recvfrom( 1024) &#10;data, addr &#10;# Stop the timer: &#10;stop = time. time() &#10;print(&quot;Packet received from &quot;+ &#10;data. decode(encoding= ascii ' )) &#10;# Look up the Python documentation for the timeout value on datagram socket &#10;print ( &quot;Round-trip-time (RTT) : &#10;&quot;+str(stop -start) &#10;except • &#10;client &#10;# Otherwise, assume the packets lost and print &quot;Request timed out&quot; &#10;print(&quot;Request timed out. &#10;continue &#10;# Proceed to the next one &#10;. close() &#10;socket &#13;&#10;UDP_ping_client.py&#13;&#10;Untitled picture.png 6 &#10;7 &#10;8 &#10;9 &#10;10 &#10;12 &#10;14 &#10;16 &#10;17 &#10;18 &#10;19 &#10;20 &#10;22 &#10;socket (AF_INET, SOCK DGRAM) &#10;serverSocket &#10;# Assign IP address and port number to socket &#10;serverSocket. bind ( ( , &#10;12eeø) ) &#10;while True: &#10;# Generate random number in the range of 0 to le &#10;random. randint(e, le) &#10;rand &#10;# Receive the client packet along with the address it is coming from &#10;serverSocket. recvfrom( 104) &#10;message, address &#10;print (&quot;THe message received is &#10;message) &#10;# Capitalize the message from the client &#10;message. upper( ) &#10;message &#10;# If rand is &#10;if &#10;rand &#10;continue &#10;# Otherwise, &#10;serverSocket &#10;less is than 4, we consider the packet lost and do not respond &#10;the server responds &#10;. sendto(message. encode() , &#10;address) &#13;&#10;UDP_ping_server.py&#13;&#10;hw2: Implementation&#13;&#10;TCP Socket Flow&#13;&#10;Socket Programming with TCP &#13;&#10;" 
src="Lecture%20note_v3_files/mhtCCD2(1).tmp" width=1070 height=960><BR><IMG 
alt='sockets-tcp-flow.1da426797e37.jpg TCP socket flow&#13;&#10;&#13;&#10;Untitled picture.png Server (running on hostid) &#10;Create socket bound to port x for incoming request: &#10;serv sock &#10;= SOCK_STREAM) &#10;serv_sock. x)) &#10;serv_sock. listen (1) &#10;Wait for incoming &#10;connection request &#10;conn sock, addr = &#10;serv_sock. accept ( ) &#10;TCP &#10;connection setup &#10;e request from conn_sock &#10;via recv(. &#10;Write reply to conn_sock &#10;(via send &#10;Close conn sock &#10;Client &#10;Create socket, connect to hostid, port x &#10;client sock = &#10;SOCK_STREAM) &#10;client _ sock. x)) &#10;Send request using client _ sock &#10;(via send( . &#10;Read reply from client_sock &#10;(via recv( . &#10;Close client sock &#13;&#10;TCP Socket Flow&#13;&#10;Untitled picture.png Python TCP Client &#10;from socket import * &#10;- SOCK_STREAM) &#10;clientSocket — &#10;clientSocket. connect( ("121.3.25.62" , &#10;12eø0) ) &#10;clientSocket . send ("hello ! " . encode( ) ) &#13;&#10;Overall Operation&#13;&#10;TCP Client: Create socket(SOCK_STREAM) ==> make connection to server(“121.3.25.62”, 12000) ==> Send encoded message to server ==> Close it&#13;&#10;' 
src="Lecture%20note_v3_files/mhtCCF4(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Python TCP Client &#10;from socket import * &#10;- SOCK_STREAM) &#10;clientSocket — &#10;clientSocket. connect( (&quot;121.3.25.62&quot; , &#10;12eø0) ) &#10;clientSocket . send (&quot;hello ! &quot; . encode( ) ) &#13;&#10;Create TCP socket in client side&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;Server &#10;Client &#10;SYN &#10;SYN JACK &#10;ACK &#13;&#10;TCP is an reliable protocols, so it will need to build an TCP connection between client and server before any communication, by Three hand-shake.&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;the message that client want to send&#13;&#10;writing data to TCP send buffer, and it's the responsibility of TCP to send message to TCP receive buffer. &#13;&#10;ConnectionSocket.recv(1024) will receive the packet. 1024 is the maximum number of byte allow to receive, any thing beyond that will be remain in TCP receive buffer.&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;The data is transferred in byte, so you need to convert to human language&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;A detail looking&#13;&#10;Untitled picture.png Python TCP Server &#10;from socket import * &#10;serversocket = socket (AF_INET, SOCK_STREAM) &#10;serverSocket . bind( ( &#10;, 12øøe)) &#10;serverSocket . li sten (1) &#10;connectionSocket, addr = serverSocket . accept() &#10;bytestream = connectionSocket . recv(1Ø24) &#10;bytestream = bytestream. decode() &#13;&#10;Overall Operation&#13;&#10;Untitled picture.png 5 &#13;&#10;TCP Server: create a socket(SOCK_STREAM) ==> Bind the port number to socket( .bind((“”, 12000)) )==> Acknowledge the connection from client ==> recv packets from client and decode it&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCD16(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Python TCP Server &#10;from socket import * &#10;serversocket = socket (AF_INET, SOCK_STREAM) &#10;serverSocket . bind( ( &#10;, 12øøe)) &#10;serverSocket . li sten (1) &#10;connectionSocket, addr = serverSocket . accept() &#10;bytestream = connectionSocket . recv(1Ø24) &#10;bytestream = bytestream. decode() &#13;&#10;Untitled picture.png 5 &#13;&#10;&#13;&#10;Create TCP socket in server side as &quot;welcoming socket&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;binding the ip addr and port number to socket&#13;&#10;By setting the first argument to empty, it allows server to receive package from multiple client. Otherwise it will only received packet from certain user&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;Queueing request. &#13;&#10;(1) means the maximum number allow to queue is 1 packet&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;welcoming socket will return the client socket and it's ip address&#13;&#10;A blocking call, if no request, it will just waiting.&#13;&#10;If on client attempt to connect the server, it will send an connect request. connect() is a blocking call as well, it will wait server respond, before sending message&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;After building the reliable connection, TCP will pass the sequence of byte to the socket, and truncate to transport layer packages.&#13;&#10;Byte stream &#13;&#10;there can be &#13;&#10;You need to create a socket for each time you want to send an package&#13;&#10;To create an &quot;Welcoming TCp socket&quot; at server side. So, every-time a client want to send an package to server, it send to an certain port only (let's call it welcome port). Moreover, it will create an connection socket, &#13;&#10;problem of TCP protocol &#13;&#10;Untitled picture.png Socket Programming with TCP &#10;Client app. &#10;IP: 220.0.43.12 &#10;Port: 11000 &#10;Python TCP Client &#10;from socket import * &#10;clientSocket — &#10;- SOCK_STREAM) &#10;clientSocket. connect( ( &quot;121.3.25.62&quot; , &#10;12eøø)) &#10;clientSocket. send ( &quot;hello encode( ) ) &#10;clientSocket. close( ) &#10;&quot;hello!&quot; &#10;Server &#10;IP: 121.3.25.62 &#10;port: 12000 &#10;Python TCP Server &#10;from socket import * &#10;serverSocket — &#10;- SOCK_STREAM) &#10;serverSocket . bind( &#10;12000)) &#10;serverSocket. listen (1) &#10;connectionsocket, addr = serverSocket. accept() &#10;bytestream = connectionsocket . recv(1024) &#10;bytestream = bytestream. decode() &#10;connectionsocket . close( ) &#10;serverSocket . close( ) &#13;&#10;" 
src="Lecture%20note_v3_files/mhtCD39(1).tmp" width=1070 height=960><BR><IMG 
alt="that use listen(num_client), to specify the maximum number of client you want to take time&#13;&#10;and use an while loop, and established multiple connectionSocket to the client &#13;&#10;What happen if have multiple client:&#13;&#10;No, there something called &quot;Flow control&quot;, sending buffer would send any data that is beyond the capacity of receive buffer&#13;&#10;What if we have a very large data, which beyond the size of receive buffer, want to send to server, would the packet get lost?&#13;&#10;&#13;&#10;Untitled picture.png Socket Programming with TCP &#10;Client app. &#10;IP: 220.0.43.12 &#10;Port: 11000 &#10;Python TCP Client &#10;from socket import * &#10;clientSocket — &#10;- SOCK_STREAM) &#10;clientSocket. connect( ( &quot;121.3.25.62&quot; , &#10;12eøø)) &#10;clientSocket. send ( &quot;hello encode( ) ) &#10;clientSocket. close( ) &#10;&quot;hello!&quot; &#10;Server &#10;IP: 121.3.25.62 &#10;port: 12000 &#10;Python TCP Server &#10;from socket import * &#10;serverSocket — &#10;- SOCK_STREAM) &#10;serverSocket . bind( &#10;12000)) &#10;serverSocket. listen (1) &#10;connectionsocket, addr = serverSocket. accept() &#10;bytestream = connectionsocket . recv(1024) &#10;bytestream = bytestream. decode() &#10;connectionsocket . close( ) &#10;serverSocket . close( ) &#13;&#10;Problem of telephone number : hard to remember&#13;&#10;Solution: use your friends name&#13;&#10;Analogy: &#13;&#10;Untitled picture.png 32 bit IP address (e.g., 127.11.3.20) &#10;• IPv6 addresses 128 bits long &#10;• Public IP addresses are reachable by anyone over the Internet &#13;&#10;Because it's hard to remember IP address. However the router can't easily deal with English-variable names when doing packet forwarding (DNS is hard to implement lookup table, all english words, and lack of security), so IP address is better for lookup table (Because your router need to figure our where to send your data, and the way your router can figure out is to ask lookup table).&#13;&#10;An IP (Internet Protocol) address is an address that identifies a host or router on the Internet. In version 4 of the Internet Protocol(also known as IPv4 address), a 32-bit numbers (roughly ~4B address). Version 6(aka IPv6) modifies these addresses to be 128-bit numbers. &#13;&#10;DNS(Domain name system): IP addresses are hard to remember. Imagine having to type https://172.34.56.123 every time you wanted to access a web site. Ideally, we would have a more memorable way to remember the web site. That’s where the domain name comes in. An example of a domain name is www.cs.nyu.edu. Domain names are hierarchical: www.cs.nyu.edu belongs to the edu top-level domain (TLD), the nyu subdomain within the edu TLD, the cs subdomain within the nyu subdomain, and the www subdomain within the cs subdomain.&#13;&#10;Q: Why do we need two name? (DNS and IP)&#13;&#10;DNS is the subset, or part of URL&#13;&#10;URL vs DNS&#13;&#10;Naïve solution: have a file that mapped every domain name to its IP address. (So, in early day before 1984, there was a single file called HOSTS.TXT that maintained this mapping and which  people swapped with each other over the internet. To add a new host, the host’s owner had to call an operator at Stanford Research Institute! If you don’t believe me, open up /etc/hosts on your UNIX/Mac machines. This is a remnant from the HOSTS.TXT era&#13;&#10;Another solution: have a local centralized server for lookup., (e.g. DNS server, DNS name resolution)&#13;&#10;How does the DNS were translated to IP address&#13;&#10;1/24, lectuer8-9: DNS name resolution&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCD6B(1).tmp" width=1070 height=960><BR><IMG 
alt='single point of failure&#13;&#10;difference from previous is, previous everyone have a "Address book", but right now, only one copy of "Address book" remain in centralized server&#13;&#10;But, the problem is a lot of "overhead" need to done in centralized server, because everyone is sending "lookup request" to centralized server. So, Traffic volume, Latency are the dis-adv of this solution.&#13;&#10;Another solution: have a local centralized server for lookup., (e.g. DNS server, DNS name resolution)&#13;&#10;Untitled picture.png Top-level &#10;YaÜ &#10;Figure 1: Hierarchy of DNS servers &#10;.EDU &#13;&#10;They are distributed databased, implemented in hierarchy of many name server (i.e. Local server, Root server, TLD--top-level domain servers, and authoritative servers). If local name server cannot resolve the name, it will contact the root server, and root server contact down the DNS hierarchy and returns mapping to local name server.&#13;&#10;So, how does DNS work? DNS has a hierarchy of servers that mirrors the hierarchy found in domain names themselves (Figure 1). At the top of the hierarchy are the root servers. One level below are the TLD(Top-level domain) servers, one for each TLD. Below this are the authoritative servers, typically one for each organization such as NYU, Google, or Facebook. In addition, there are also local servers owned and operated by service providers that are provided as a convenience to the end users. &#13;&#10;org: to-level domain name&#13;&#10;"wikipedia": subdomain name&#13;&#10;Example: "www.wikipedia.org"&#13;&#10;DNS was running at UDP not TCP&#13;&#10;Note:&#13;&#10;Final Solution: DNS &#13;&#10;Untitled picture.png vtM4ss - &#10;Ý¯cs &#10;osu &#10;C Se. &#10;ece. &#10;080 &#10;OSu. &#10;řnafl• 7007(e. COMh &#13;&#10;DNS hierarchy&#13;&#10;New university registering process: apply for domain name(newuniversity.edu--> after approved --> add register to Top-level domain server (.edu)&#13;&#10;Root server: has the registry of top-level server(e.g. .EDU, .COM.)&#13;&#10;Registry internet&#13;&#10;' src="Lecture%20note_v3_files/mhtCD8D(1).tmp" 
width=1070 height=960><BR><IMG 
alt="Root server: has the registry of top-level server(e.g. .EDU, .COM.)&#13;&#10;Authoritative server (e.g. mail.google.com, cse.osu.edu)&#13;&#10;local-name server: e.g.  Spectrum, AT&amp;T&#13;&#10;No, local-name server is like local network provide: AT&amp;T, Spectrum…, not part of DNS Hierachy&#13;&#10; Authoritative server == Local-name server??&#13;&#10;Yes&#13;&#10;is .edu, .com are called Domain name as well?&#13;&#10;Untitled picture.png root DNS server &#10;2 &#10;3 &#10;TLD DNS server &#10;4 &#10;5 &#10;local DNS serve &#10;dns.osu.edu &#10;7 &#10;1 &#10;8 &#10;6 &#10;authoritative DNS server &#10;dns.cs.umass.edu &#10;requesting host &#10;cse.osu.edu &#10;gaia.cs.umass.edu &#13;&#10;First requesting host contact/consult the cache, or local-name server. If it doesn't have the IP address of the domain name you ask for, then it will contact the next server(e.g. Root DNS server). If Root DNS doesn't have it, local-name server will directly contact the next server(e.g. Top-level domain server), and so on. (Root DNS server ==> TLD DNS server ==> authoritative DNS server)&#13;&#10;Iteratve query: Directly contact model&#13;&#10;Untitled picture.png root DNS server &#10;2 &#10;7 &#10;local DNS server &#10;dns.osu.edu &#10;1 &#10;8 &#10;3 &#10;6 &#10;5 &#10;TLD DNS &#10;server &#10;4 &#10;authoritative DNS server &#10;dns.cs.umass.edu &#10;requesting host &#10;cse.osu.edu &#10;gaia.cs.umass.edu &#13;&#10;First requesting query/consult the cache, or local-name server. If it doesn't have the IP address of the domain name you ask for, then the it will contact the next server(Root DNS server). If Root DNS doesn't have it, Root DNS server will be delegated to ask next server(e.g. Top-level domain server), and so on.. &#13;&#10;Recursive query: Delegation model&#13;&#10;Domain Name Resolution: Example&#13;&#10;Regardless of whether it was iterative(directly contact) or recursive(delegates the work to root DNS)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCDAF(1).tmp" width=1070 height=960><BR><IMG 
alt='&#13;&#10;Regardless of whether it was iterative(directly contact) or recursive(delegates the work to root DNS)&#13;&#10;&#13;&#10;Application layer: "message"&#13;&#10;Transport layer: "segment"&#13;&#10;IP/Networking layer: "datagram"&#13;&#10;Terminology: three terms means the same thing&#13;&#10;8 byte in total: source port(2byte, 16 bit) + dest port(2byte, 16 bit)  + length(2byte, 16 bit)  + checksum(2byte, 16 bit)  = 2byte * 4 = 8 byte&#13;&#10;Untitled picture.png 32 bits &#10;source port # dest port # &#10;length, in bytes of &#10;UDP segment, &#10;including header &#10;Idently &#10;nut-of-order &#10;length &#10;checksum &#10;application &#10;data &#10;(payload) &#10;UDP segment format &#13;&#10;Datagrame == segment&#13;&#10;payload: the actual message you want to send&#13;&#10;you want the UDP receiver to know which socket to follow&#13;&#10;Why do we need source/dest port# ?&#13;&#10;The length is useful, because different packets might have differ size&#13;&#10;Why do we need length?&#13;&#10;Detecting “errors” (e.g., flipped bits) in transmitted segment&#13;&#10;Why do we need checksum?&#13;&#10;Untitled picture.png 0 &#10;O / / 0 c &#10;/ / 6 0 &#10;0 &#10;0 &#10;0 一 , 2 &#13;&#10;This due to the nature of physical media(transmission interference, noise, lost of signal, signal attenuation…), the “errors” always exist (e.g., flipped bits) might occurs during the transmission.&#13;&#10;Problem: &#13;&#10;What is error detection and how does it happen&#13;&#10;lower overhead compared to TCP&#13;&#10;Adv:&#13;&#10;Untitled picture.png ه«ت - &#10;و &#10;دعى" لع &#10;ط«ما يبصا &#13;&#10;What actually happen in Reality:&#13;&#10;UDP: User datagram protocol&#13;&#10;1/29: Lecture10, Transport layer with UDP protocol(Ponds analogy Vs real world example), error detection mechanism(Checksum)&#13;&#10;' 
src="Lecture%20note_v3_files/mhtCDD1(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png ه«ت - &#10;و &#10;دعى&quot; لع &#10;ط«ما يبصا &#13;&#10;wireless == unguild transmission&#13;&#10;More robus, but has more constrain . (e.g. you cannot send message without the wire between two device)&#13;&#10;wire == guilded transmission&#13;&#10;Untitled picture.png 101 &#13;&#10;Goal: Alice want to send some bit to Bob&#13;&#10;communication between Charlies and Dave == Interference&#13;&#10;wind == Noise, happen caused by the nature of physical nature, e.g. thermal energy dissipation&#13;&#10;Boat/Huge rock == modern building (Concrete) will absorb the signal, and it might cause the loss of packets&#13;&#10;Three disturbance (noise, interference, loss of packets)&#13;&#10;Additional issues: signal attenuation 信号衰弱&#13;&#10;Pond analogy&#13;&#10;Untitled picture.png 0 (o &#13;&#10;sum = Dest port + source port + Payload + Length + 1(In bit)&#13;&#10;checksum = one's complement of sum&#13;&#10;Use checksum -- it's the additional segment contents&#13;&#10;So we have second layer of error detection system, which is more stricker&#13;&#10;Untitled picture.png example: add two 16-bit integers &#10;wraparound &#10;sum &#10;checksum &#10;1 &#10;1 &#10;11 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;1 &#10;o &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;1 &#10;o &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;O &#10;o &#10;1 &#10;1 &#10;1 &#10;o &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;o &#10;1 &#10;o &#10;1 &#10;o &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;Note: when adding numbers, a carryout from the most &#10;significant bit needs to be added to the result &#13;&#10;How does the checksum was calculated: &#13;&#10;But it's still possible, e.g. multiple bits flippes simultaneous and create the same checksum as the correct checksum&#13;&#10;In reality it's hard to avoid those disturbance, so we need a way, error detection mechanism, to detect the error (e.g. fliping bits)&#13;&#10;Error detection mechanism: Checksum segment&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCDF4(1).tmp" width=1070 height=960><BR><IMG 
alt="What is wraparound: because you have 17 bit after the addition, but only 16 bits is allowed, so we add that carry bit to the rest of 16 bits.&#13;&#10;Untitled picture.png example: add two 16-bit integers &#10;wraparound &#10;sum &#10;checksum &#10;1 &#10;1 &#10;11 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;1 &#10;o &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;1 &#10;o &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;O &#10;o &#10;1 &#10;1 &#10;1 &#10;o &#10;o &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;o &#10;1 &#10;o &#10;1 &#10;o &#10;1 &#10;o &#10;1 &#10;1 &#10;o &#10;1 &#10;Note: when adding numbers, a carryout from the most &#10;significant bit needs to be added to the result &#13;&#10;How does the checksum was calculated: &#13;&#10;Untitled picture.png Original Data &#10;10011001 11100010 &#10;00100100 10000100 &#10;1 &#10;2 &#10;3 &#10;1 &#10;Sender &#10;10011001 &#10;11100010 &#10;1 &#10;00100100 &#10;10100000 &#10;10000100 &#10;100100100 &#10;1 &#10;2 &#10;3 &#10;1 &#10;2 &#10;3 &#10;Re&amp;v'er &#10;10011001 &#10;11100010 &#10;1 &#10;00100100 &#10;10100000 &#10;10000100 &#10;100100100 &#10;1 &#10;00100101 &#10;11011010 &#10;Sum: 00100101 &#10;Checksum: 1 101 1010 &#10;Complement: O O O O O O O O &#10;Conclusm: Accept Data &#13;&#10;Example:&#13;&#10;Another solution, is Alice sending multiple message. It's like voting system, choose the signal that has the most votes.&#13;&#10;-->  Checking the sequence/packet number&#13;&#10;--> using checksum to match the correct computation&#13;&#10;Are there two mechanism for error detection in internet communication?&#13;&#10;&#13;&#10;bit errors&#13;&#10;packet loss&#13;&#10;Why is UDP unreliable?&#13;&#10;Reliable Data Transfer&#13;&#10;1/31&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCE06(1).tmp" width=1070 height=960><BR><IMG 
alt="packet loss&#13;&#10;packet delay&#13;&#10;differing packet might choose different route, so the time it take to travel might differ. So the original packing order might be break.&#13;&#10;packet reordering: &#13;&#10;Packet duplication: getting multiple packet at different time&#13;&#10;Untitled picture.png LV &#13;&#10;Just keep sending the packages, and no any checking or connection would need&#13;&#10;if everything is perfect, none of above 5 bad thing would happen, what does a reliable protocol would looks like? &#13;&#10;Untitled picture.png cena%' o &#10;Sou &#10;Ceu &#10;aceiV€r &#13;&#10;if error happened --> server ask for sending the same packet again&#13;&#10;otherwise --> keep sending the next one&#13;&#10;Note: don't keep the sender hanging &#13;&#10;What if break the condition i) bit errors?&#13;&#10;Ack: acknowledge &#13;&#10;Nack: non-acknowledge&#13;&#10;If no error, send Ack&#13;&#10;if errors, send Nak&#13;&#10;Receiver:&#13;&#10;if Ack comes back, send next packet&#13;&#10;Sender:&#13;&#10;Packet Reliability: Ack &amp;&amp; Nak protocal &#13;&#10;Stop-and-wait protocol: Version 1&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCE28(1).tmp" width=1070 height=960><BR><IMG 
alt="if Ack comes back, send next packet&#13;&#10;If Nak comes back, send the same packet&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;secure &#10;Tender &#10;check &#10;NAK &#10;exxon NAK &#10;&#13;&#10;There are two possible scenarios, 1) The Ack get corrupted -- Sender send same packet again, the problem of duplication would occur. 2)The Nak get corrupted-->sender send same packet agains, so works fine, the sender still need to send the same packet again!&#13;&#10;It's two way communication, so what if the Ack send by receiver was get corrupted?&#13;&#10;Stop-and-wait protocol V2&#13;&#10;Untitled picture.png kt &#10;rcv pkt &#10;send ack &#10;kt &#10;rcv pkt &#10;same &#10;packet &#10;sent &#10;twice! &#13;&#10;Solution is including a packet number: adding an ID (packet number) for each packet, so receiver would know if two are the same if two packet has identical packet number, and receiver can discard the duplication!&#13;&#10;Problem of duplicated packet (receiver get confused: &quot;why are you sending me the same packets again?&quot;)&#13;&#10;Sender would keep waiting&#13;&#10;So we might want to setup timeout mechanism&#13;&#10;Such as the ack that receiver send get loss? What would happen?&#13;&#10;Too short: premature timeout, unnecessary retransmissions&#13;&#10;Too long: slow reaction to packet loss&#13;&#10;Retransmissions timer: We can do an estimation, such the avg of traveling time of previous packets, if longer than 95% CI, we can just assume the packet get lost!&#13;&#10;RTT(round-trip time): the time for packet travel from sender to receiver, and from receiver back to sender.&#13;&#10;So, how long we should wait? --> retransmission timer&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;350 - &#10;50 my &#10;time &#13;&#10;Taking the average of most recently 5 samples (measured RTT time)&#13;&#10;naïve solution: &#13;&#10;What if break the condition ii) no packet loss?&#13;&#10;Stop-and-wait protocol V3&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCE3B(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Machine generated alternative text:&#10;&#10;350 - &#10;50 my &#10;time &#13;&#10;Untitled picture.png SampleRTT: measured time from &#10;segment transmission until ACK receipt &#10;SampleRTT will vary, want a &#10;&quot;smoother&quot; estimate &#10;Solution: average over several recent &#10;measurements &#10;• sampleRTT &#10;time (seconds) &#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;&#13;&#10;Because The fact that the weights decrease exponentially&#13;&#10;alpha takes effect on current RTT, and (1 - alpha) takes effect on the history of sample RTT.&#13;&#10;The larger the alpha, the more likely you want to forget the past. The smaller the alpha, the more likely you want to remember the past. &#13;&#10;Why it's called EWMA?&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;RIT = ( 1 4 ) 0 7 0 ( RTT 2 ) = ( RT 1) &#10;RTTIG &#10;RTT 2 &#10;1 4 (RT-2 ) + 2 ( RT1 2 ) &#10;BIT &#10;RTT - 2 &#10;RTT -2 &#10;RTT -3 &#10;RTT - 4 &#10;RTIS &#13;&#10;�HYPERLINK &quot;http://www.math.montana.edu/jobo/st528/documents/chap9d.pdf&quot;Exponential weighted moving average (EWMA): Taking the last 5(x) samples, the most recent packets, and to take the average on them. So, we discard the old data, and only look at the recent packet. &#13;&#10;TimeoutInterval estimated the time sender should wait before retransmission happens&#13;&#10;Untitled picture.png Estimate SampleRTT deviation from EstimatedRTT: &#10;DevRTT = (1 —ß)DevRTT + ßlsamp1eRTT - &#10;EstimatedRTT I &#10;(typically &#10;, = 0.25) &#10;Timeoutlnterval &#10;= EstimatedRTT + 4*DevRTT &#10;estimated RIT &quot;safety margin&quot; &#13;&#10;Compute the deviance of RTT, and use it to estimate TimeoutInterval&#13;&#10;Better solu:&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCE5D(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Estimate SampleRTT deviation from EstimatedRTT: &#10;DevRTT = (1 —ß)DevRTT + ßlsamp1eRTT - &#10;EstimatedRTT I &#10;(typically &#10;, = 0.25) &#10;Timeoutlnterval &#10;= EstimatedRTT + 4*DevRTT &#10;estimated RIT &quot;safety margin&quot; &#13;&#10;Untitled picture.png Sender: &#10;• Send packet including sequence &#10;number &#10;• Start timer for packet &#10;• If Ack comes back within &#10;Timeout Interval seconds, send &#10;next packet, else send same packet and &#10;reset timer &#10;• If Nak comes back, send same packet &#10;and reset timer &#10;Receiver: &#10;• Check received packet for any errors &#10;(using checksum) &#10;If no errors, then send Ack &#10;• &#10;• If errors, then send Nak &#10;Include packet number in Ack/Nak &#10;• &#13;&#10;Keyword: packet number, Ack/Nck, error detection(with checksum), Timeout-Interval(EWMA)&#13;&#10;Ack/Nak&#13;&#10;Packet number&#13;&#10;Retransmission timer&#13;&#10;main ideas for reliability&#13;&#10;Untitled picture.png rcv ackO &#10;send pktl &#10;timeou &#10;resend pktl &#10;rcv ackl &#10;send pkt2 &#10;rCV &#10;acu——— send ackl &#13;&#10;If the pkt1 that sender sends get lost, receiver won't receive it, and then for a period of time, sender will sent it again&#13;&#10;Packet loss while sending to receiver --> solution: retransmission timeout&#13;&#10;Untitled picture.png rcv ackO &#10;send pktl rcv pktl &#10;send ackl &#10;timeout &#10;resend pktl rcv pktl &#13;&#10;Ack loss while getting back to sender --> Solution: Retransmission timeout&#13;&#10;Three scenarios&#13;&#10;Stop-and-wait protocol: Final version&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCE70(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png rcv ackO &#10;send pktl rcv pktl &#10;send ackl &#10;timeout &#10;resend pktl rcv pktl &#13;&#10;But if timeout is too short, &#13;&#10;Untitled picture.png rcv ackO &#10;ktl &#10;send pktl rcv pktl &#10;timeout &#10;resend pktl &#10;rcv ackl &#10;send pkt2 &#10;rcv ackl &#10;(detect duplicate) &#10;rcv ack2 &#10;ack 1 &#10;ack 1 &#10;send ackl &#10;rcv pktl &#10;(detect du&amp;lifate) &#10;send a &#13;&#10;Premature timeout/delayed Ack&#13;&#10;Throughput: total length of packet(bit) / total amount of time had taken(sec)&#13;&#10;Untitled picture.png sender &#10;first packet bit transmitted, t = O &#10;last packet bit transmitted, t = L/ R &#10;receiver &#10;first packet bit arrives &#10;last packet bit arrives, send ACK &#10;L = 8000 bit packet &#10;R = 1 Gbps link &#10;RTT = 30 ms &#10;RTT &#10;ACK arrives, send ne &#10;packet, t = RTT + L/ R &#10;Utilization = &#10;+ RTW &#10;= 0.027% &#10;Throughput = &#10;= 266 kbpeva &#10;+ RTT &#13;&#10;Utilization: transmission delay(in sec) / (Round trip time + transmission delay)(in sec)&#13;&#10;How to measure the performance&#13;&#10;Untitled picture.png sender &#10;first packet bit transmitted, t = O &#10;last bit transmitted, t = L/ R &#10;RTT &#10;ACK arrives, send next &#10;packet, t = RTT + L/R &#10;receiver &#10;first packet bit arrives &#10;last packet bit arrives, send ACK &#10;last bit of 2rxd packet arrives, send ACK &#10;last bit of 3rd packet arrives, send ACK &#10;L = 8000 bit packet &#10;R = 1 Gbps link &#10;RTT = 30 ms &#10;Utilization = &#10;= 0.081 % &#10;Throughput = &#10;= 800 kbps &#13;&#10;Pipelining: Sending the other packet before the Ack/Nak being received&#13;&#10;Anyway to improve the performance?&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCE92(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png sender &#10;first packet bit transmitted, t = O &#10;last bit transmitted, t = L/ R &#10;RTT &#10;ACK arrives, send next &#10;packet, t = RTT + L/R &#10;receiver &#10;first packet bit arrives &#10;last packet bit arrives, send ACK &#10;last bit of 2rxd packet arrives, send ACK &#10;last bit of 3rd packet arrives, send ACK &#10;L = 8000 bit packet &#10;R = 1 Gbps link &#10;RTT = 30 ms &#10;Utilization = &#10;= 0.081 % &#10;Throughput = &#10;= 800 kbps &#13;&#10;No, if your first packet get loss, there is higher chance your next packet would get loss as well!&#13;&#10;So, is good to keep sending more packet?&#13;&#10;A pond has a limited amount of &quot;ripple&quot; it can hold. Similarly, transmission link also has limited for the number of packet you can send, and it's same for the buffer link. So, if you send more packet the link can hold, the excessive packet would get drop.&#13;&#10;So, what would be a good number of packet we should send?&#13;&#10;It doesn't know, but can be estimated&#13;&#10;So, how does sender know the capacity of network?&#13;&#10;Untitled picture.png ( VU &#13;&#10;Idea: Assume the sender know the capacity of network. We will use a counter to figure out how many packet we can send. Send one packet, increment the counter. Receive a ACK, decrement the counter. So, the counter tells use the amount of packet in the network!&#13;&#10;Even sender know the capacity of network, how does it can ensure it doesn't send too many packet than the network can support?&#13;&#10;In worse scenario, the number of packet need to be buffered = counter - number of packet get &quot;un-ack&quot;&#13;&#10;In best scenario, zero number of packet would need to be buffered&#13;&#10;How does sender know how many packet had been buffered at receiver side?&#13;&#10;window size: the number of packet sender allow to send within a RTT round.&#13;&#10;you slide the window until the first packet received, so all the packet had arrived, and can be process/reassemble to original orders!&#13;&#10;Assume knowing the capacity, and number of packet in receiver buffered ==> chosse the min of these two&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;Application layer &#10;1 1 5432 ) &#13;&#10;Window: &#13;&#10;" 
src="Lecture%20note_v3_files/mhtCEA5(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Machine generated alternative text:&#10;&#10;Application layer &#10;1 1 5432 ) &#13;&#10;&#13;&#10;ACK/Nak&#13;&#10;Sequence Number&#13;&#10;Retransmission timer&#13;&#10;Sliding window&#13;&#10;Review four way to ensure the reliability for TCP&#13;&#10;Untitled picture.png 0123 &#10;D 123 &#10;0123 &#10;0123 &#10;01 &#10;5678 &#10;5678 &#10;5678 &#10;5678 &#10;. 1234. &#10;678 &#10;2345. &#10;2345. &#10;2345. &#10;2345. &#10;78 &#10;78 &#10;78 &#10;78 &#10;78 &#10;send pktO &#10;send pktl &#10;send pkt2 &#10;send pkt3 &#10;(wait) &#10;rcv ackO, send pkt4 &#10;rcv ackl, send pkt5 &#10;record ack3 arrived &#10;pkt 2 timeout &#10;send pkt2 &#10;record ack4 arrived &#10;record ack5 arrived &#10;Q: what happens when ack2 arrives? &#10;receiver &#10;receive pktO, send ackO &#10;receive pktl, send ackl &#10;receive pkt3, buffer, send ack3 &#10;receive pkt4, buffer, send ack4 &#10;receive pkt5, buffer, send ack5 &#10;rcv pkt2; deliver pkt2, pkt3, pkt4, pkt5; &#10;send ack2 &#13;&#10;slide window will move to pkg6. All the 3,4, and 5 had received, so when pkg arrived, the slide window is ready to move.&#13;&#10;Sender: if there are unsued seq 3 available in window, send packet&#13;&#10;Window protocal cont…&#13;&#10;Untitled picture.png t=O &#10;t=l-/R &#10;t = RTT + L/ &#13;&#10;Performance of sliding window:&#13;&#10;2/7: Lecture 14(Window protocal, Congestion control)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCEB7(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png t=O &#10;t=l-/R &#10;t = RTT + L/ &#13;&#10;Untitled picture.png Utilization WL &#10;R+RTT ¯ R RTT &#13;&#10;W = window side&#13;&#10;L is the length of packet, bit&#13;&#10;R is the transmission rate. Aka, link capacity in unit bit/sec&#13;&#10;L/R = transmission delay, in sec&#13;&#10;RTT = Round trip-delay time, in sec. latency from a host A to host B and back to host A. This is simply twice the one-way latency of going from host A to host B, if the forward and return paths are symmetric&#13;&#10;It's equivalent to the maximum amount of data you can send in sec. Practically R*RTT is way larger than L/R, so we can approximate it with R*RTT&#13;&#10;Untitled picture.png Moderate speed satellite network: 512 köitJs, 900 ms round-trip time (RTT) &#10;BxD= 512 x 103 b/s • 900 x 10-3 s &#10;= 460, 800b = 460.8 kb = 57.6kB &#13;&#10;Ex: &#13;&#10;R*RTT = data link's capacity(in bits/sec) * RTT(in sec), maximum amount of data user allowed to send. Aka bandwidth delay product&#13;&#10;Utilization = Amount of time being occupied / total time&#13;&#10;Untitled picture.png Throughput &#10;L &#10;R + RIT &#10;— RTT &#13;&#10;Throughput吞吐量: == how fast the sender is sending, so the windows size is proportional to the throughput&#13;&#10;Untitled picture.png • Utilization cannot be more than 100% &#10;WL &#10;sender &#10;t=L/R &#10;t=RTT+L/R &#10;receiver &#10;WL &#10;Utilization = &#10;R *RTT &#10;• Therefore, W _ &#10;bandwidth-delay &#10;product &#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;PARTY &#10;&#13;&#10;No, if you pipeline too many packet, it might cause heavy congestion. Therefore the maximum utilization is: &#13;&#10;Can we just keep increasing W(window size) for greater utilization and throuput? If not, what is the  right window size?&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCEDA(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Machine generated alternative text:&#10;&#10;PARTY &#10;&#13;&#10;R*RTT aka the bandwidth delay product&#13;&#10;Why do we let the utilization to 1&#13;&#10;Bandwidth delay product(带宽时延乘积) depends on R and RTT. R is the bottleneck transmission rate(The smallest bandwidth/capacity of link at the transmission path, which changes over time. RTT depend on whether the sender or a receiver is on a WiFi, Ethernet, or 4G link. Each link technology has different propagation delay. Also, RTT can change because of the changes in network path between sender and the receiver (e.g. A router was taken down for maintenance). Thus, neither R nor RTT is known up front, and setting the sliding window size to BDP is impractical.&#13;&#10;The R here refers to the Bottleneck bandwidth(The smallest bandwidth/capacity of link at the transmission path). Ex, in Youtube server, there can be million of user in using these application, so if the Bandwidth at server size may be the bottleneck bandwidth.&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;R Bottleneck Bandwidth &#10;cabal &#13;&#10;Because you only know the bandwidth at your Access network(Router), and you had no way of knowing the bandwidth/transmission rate at others router. &#13;&#10;Q: Why is estimating the BDP is hard?&#13;&#10;If the window size beyond BDP, it will worse the delay, and cause a negative feedback loop. Queue has finite numbr of buffer, if you send excessive packet, and it will cause buffer overflow, and the packet might get dropped. So, packet drop, and timeout&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;ask &#10;rate ? &#10;transmission on &#10;Window Size ( W ) &#13;&#10;It may cause buffer overflow, and packets would get dropped, and then retransmission would happen.&#13;&#10;Q: Estimating bandwidth-product is difficult, what happen if we set W larger than BDP? When we don’t allow to do that?&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCEEC(1).tmp" width=1070 height=960><BR><IMG 
alt="When the window size(W) beyond the BDP, the transmission rate increase, but due to the retransmission(associated with timeout interval), more and more packet get loss and transmission rate get wasted!&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;ask &#10;rate ? &#10;transmission on &#10;Window Size ( W ) &#13;&#10;Untitled picture.png cQlcu) &#13;&#10;queuing size == number of packets in the buffer&#13;&#10;WL == maximum number of packets allow to send&#13;&#10;R*RTT == maximum number of packet live in Bottleneck link&#13;&#10;==> Average Queuing delay = (WL - RTT)/R <==> think of t = s/v, queuing delay is like the average waiting time&#13;&#10;==> So larger the window size, worse the queuing delay&#13;&#10;WL is the maximum size of packet allow to send, and (R*RTT) is the maximum transmission rate ==> So WL- (R*RTT) is the maximum queuing size&#13;&#10;queuing size, WL, R*RTT == distance&#13;&#10;transmission rate (R ) == velocity&#13;&#10;RTT, queuing delay == time&#13;&#10;Analogy of physic: &#13;&#10;Queuing delay with large window&#13;&#10;Ex: If queue size grows, and this time, if you upload a very large file to DropBox, most likely packets will be dropped and/or packet timer will trigger, which leading to retransmission of packets&#13;&#10;Retransmission of packets:&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;Receive &#10;backup &#10;Sound &#10;trip &#10;( RT) &#10;packets ? &#13;&#10;Review:&#13;&#10;2/10-2/12&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCF0F(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Machine generated alternative text:&#10;&#10;Receive &#10;backup &#10;Sound &#10;trip &#10;( RT) &#10;packets ? &#13;&#10;So the throughtput is determiend by the window size, but the windows size cannot beyond the limit of bandwidth, so if you want a fast network speed, not only you should increase the bandwidth but also the server side, because here, we are talking able the bottleneck bandwidth&#13;&#10;Throughtput is determined by the WL/RTT, Rtt is fixed, as well as the packet size(L)&#13;&#10;Why is the throughput determine by L(length of packet)?&#13;&#10;The speed of network is determined by the bottleneck bandwidth&#13;&#10;Transmission rate is determined by the transmission media, e.g. optic fiber, or the speed of electromagnetic signal wave&#13;&#10;Is tranmission rate equivalent to Network speed? ==>&#13;&#10;Untitled picture.png • If WL > bandwidth-delay product, packets would start queuing &#10;Sender &#10;• Queue size = WL — (R * RTT) bits &#10;• Queuing delay &#10;— RTT seconds &#10;• (Little's law) &#10;link rate = R &#10;Receiver &#10;Note: RTT here refers to round-trip-time without any queueing &#10;Making window size too large &#10;worsens delay! &#13;&#10;Untitled picture.png Sender 1 &#10;Window WI &#10;Sender 2 &#10;Window W2 &#10;Sender 3 &#10;Window Wa &#10;Sender 4 &#10;Window Wa &#10;Total number Of in-flight packets = WI + W2 + WA + Wd &#10;link rate = R &#10;Receiver &#10;Packets dropped even if individual windows are small! &#13;&#10;If queue ize grows, ackets will get dropped and/or packet timers will trigger, which leads to the retransmission of packets:&#13;&#10;Queuing delay with large window&#13;&#10;&#13;&#10;�HYPERLINK &quot;https://cs.nyu.edu/~anirudh/lectures/lec6.pdf&quot;Congestion collapse&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCF31(1).tmp" width=1070 height=960><BR><IMG 
alt="&#13;&#10;Offered load is depends on the number of packet were send from sender&#13;&#10;goodput is the rate of useful packet being received by receiver&#13;&#10;At peak, as the number of user(workload) increase, Due to the limit of bandwidth? queuing size, the applicable transmission capacity decrease, so the pack drop and retransmission happened.&#13;&#10;Untitled picture.png Goodput &#10;Net rate at which packets &#10;are received by application &#10;layer at receivers &#10;Offered load &#10;Net rate at which packets are &#10;sent by transport layer at senders &#13;&#10;Congestion collapse is a term for a situation in which the offered load (i.e. the demand for the network’s services) is increasing, but the Goodput (overall utility of the network) to its users is decreasing. Possibly it's caused by a single user picked a very large W or there are too many users sharing a link, and the packets get dropped, and send again, and so on. As a result,  they just keep sending multiple copies of packet, and the transmission caused the queueing delay to grow further, and lead to even more retrainsmission, which soon leads to even more queues.&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;250 KG/ &#10;User 2 &#13;&#10;Ex: User purchased the 250kb/s bandwidth, but in practise, they only gain the 1/10 of bandwith that they paid&#13;&#10;每个link上的transmission rate都会不同, 但是Throughput值得就是一个具体的值, that is the bottlenect transmission rate&#13;&#10;Transmission rate == Throughput? ==> No&#13;&#10;�HYPERLINK &quot;https://cs.nyu.edu/~anirudh/lectures/lec6.pdf&quot;Congestion collapse&#13;&#10;Slow start: similar to accelerating phase, to get the right speed on the highway.&#13;&#10;Two phase of congestion control: Slow start, and Congestion avoidance&#13;&#10;�HYPERLINK &quot;https://cs.nyu.edu/~anirudh/lectures/lec7.pdf&quot;Congestion control: How to Find &quot;Right&quot; window size?&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCF43(1).tmp" width=1070 height=960><BR><IMG 
alt="Initialize the window size to 1, and double window size for each ACK received. Whenever a packet loss detected, it cuts the windows size down to half. After this, it enters a mode called congestion avoidance, where much more gentle changes to the window size.&#13;&#10;Initial rate(==1) is slow but ramps up exponentially&#13;&#10;Slow start: similar to accelerating phase, to get the right speed on the highway.&#13;&#10;Untitled picture.png AIMD saw tooth &#10;behavior: probing &#10;for bandwidth &#10;additively increase window size &#10;until loss occurs (then cut window in half) &#10;time &#13;&#10;We use AIMD (additive-increase multiplicative-decrease) algorithm to adjusted window size dynamically. It allows a sliding window sender to adaptively find a window size equal to the BDP of the network. -- 上升的话每次加一，下降的话直接减半。&#13;&#10;Concept: In Congestion avoidance, the sender increases its window by 1 every RTT, as opposed to 1 every ACK in Slow Start. This means the window size increases additively by a constant amount. It decreases its window in the same way as Slow Start, by halving the window. In other words, the decrease is multiplicative.&#13;&#10;Additive increase: increase windom size by 1 for every RTT&#13;&#10;Multiplicative decrease: Cut in half whenever a lost occurred&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;Receiver &#10;PKK &#10;Windows &#10;Window &#10;received &#10;I Hack &#10;RTT 2 RX 3 77 4 RIT &#13;&#10;Q: Why do we call it AIMD&#13;&#10;Congestion Avoidance: similar to maintaining this speed in highway&#13;&#10;There are many variation of TCP (depends of your Internet Provide, e.g. ATT), and they might have different strategies in defining the severity of loss/congestion&#13;&#10;e.g. timeout error occurred, tons of packet get loss --> more serious loss --> reset to slow start phase&#13;&#10;e.g. several duplicated packet error occurred, few packet get lost --> mild loss  ==> Don't care&#13;&#10;when TCP received multiple ACK, it knows it's gonna be a serious congestion, so it's more likely will be reset to slow start , if just one packet probably not. &#13;&#10;Q: Do we always reset to slow start phase whenever a loss event occurs? --> depends on severities&#13;&#10;TCP fairness&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCF66(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png TCP connection I &#10;TCP connection 2 &#10;bottleneck &#10;router &#10;capacity R &#13;&#10;Ex: if there are two TCP connection, fairly speaking, the capacity rate of two flow should be split evenly&#13;&#10;flows: an TCP connection&#13;&#10;The dashed line is equally splied situation&#13;&#10;Untitled picture.png e &#10;0 &#10;equal bandwidth share &#10;loss: decrease window by factor of 2 &#10;congestion avoidance: additive increase &#10;loss: decrease window by factor of 2 &#10;congestion avoidance: additive increase &#10;Connection 1 throughput &#13;&#10;Example of two competing connection: Conn 1 might connect at first before Conn 2, so the Conn 1 might has a larger window size than Conn 2, but TCP would adjusted them evenly and gradually.&#13;&#10;TCP fairness&#13;&#10;Untitled picture.png 32 bits &#10;source port # &#10;dest port # &#10;sequence number &#10;acknowledgement number &#10;c &#10;counting &#10;by bytes &#10;of data &#10;(not packets!) &#10;# bytes &#10;rcvr willing &#10;to accept &#10;RST, SYN, FIN: &#10;connection estab &#10;(setup, teardown &#10;commands) &#10;Internet &#10;checksum &#10;(as in UDP) &#10;receive window &#10;um &#10;application &#10;data &#10;(variable length) &#13;&#10;source/dest port: the port number of sender/receiver&#13;&#10;RST:  reset&#13;&#10;Flags:&#13;&#10;TCP segment structure&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCF88(1).tmp" width=1070 height=960><BR><IMG 
alt='RST:  reset&#13;&#10;FIN: finished connection?&#13;&#10;sequence number were decided by the number of byte of data, so they might have difference sequence number at the beginning. &#13;&#10;SYN: both have a sequence number, and they are initialize randomly, we want to know the staring number of you packet, and you want to know the starting sequence number of my packet as well, so SYN could tell us &#13;&#10;Receive window: # of byte rcvr is willing to accept&#13;&#10;Ack/Nak protocal communication&#13;&#10;Sequence Number == packet number&#13;&#10;Retransmission&#13;&#10;Window sliding--> to have both utilization and realiability&#13;&#10;Congestion control&#13;&#10;Five methods to provide reliable TCP connection&#13;&#10;if the reliability is not seriously important, and a fast transmission is desired--> UDP, and skype, &#13;&#10;Netflix, Facebook, website, almost everything is using TCP, &#13;&#10;example of buffering/loading when you watching youtube&#13;&#10;If you want a strong reliability --> TCP, but might suffer from congestion, e.g. Browsing website&#13;&#10;When to use UDP? and When to use TCP?&#13;&#10;Summary:&#13;&#10;nyu, �HYPERLINK "https://cs.nyu.edu/~anirudh/lectures/lec6.pdf"Lecture 6: Congestion collapse,&#13;&#10;&#13;&#10;Bandwidth-delay product, �HYPERLINK "https://en.wikipedia.org/wiki/Bandwidth-delay_product"https://en.wikipedia.org/wiki/Bandwidth-delay_product&#13;&#10;Resource: &#13;&#10;Sending side: encapsulate transport layer segments into IP datagrams&#13;&#10;Routers: examine header of IP datagram and to determine the route a packet should forward&#13;&#10;Receiving side: deliver transport layer segment from network layer to transport layer&#13;&#10;"transport layer segments" is defined as the packets in Transport layer&#13;&#10;"datagram" is defined as the packet in Network layer&#13;&#10;Routing: Decide the overall route taken by packet from source to destination&#13;&#10;Untitled picture.png علهم &#13;&#10;Each router has a forwarding table:&#13;&#10;In the forwarding table at router A, if we know the path of packet (A->B), so the next router to forward is B&#13;&#10;Network operator: like ATT, the networking decide what the path the packet to go&#13;&#10;Forwarding: Decide which path to go in certain intersection/router, an local operation for particular router.&#13;&#10;Terminology: &#13;&#10;02/17  Lecture16, Routing layer&#13;&#10;' 
src="Lecture%20note_v3_files/mhtCFAA(1).tmp" width=1070 height=960><BR><IMG 
alt="In the forwarding table at router A, if we know the path of packet (A->B), so the next router to forward is B&#13;&#10;In the forwarding table at router A, if we know the path of packet (A-->E), so the next router to forward is F&#13;&#10;In the forwarding table at router A, if we know the path of packet (A-->D), so the next router to forward is F&#13;&#10;“Forwarding” is about moving a packet from a router’s input link to the appropriate output link. “Routing” is about determining the end-to-routes between sources and destinations.&#13;&#10;What is the difference between routing and forwarding?&#13;&#10;Control plane: determine how datagrame is routed from Source host to Dest host (E.g. Network-wide logic, routing algorithm)&#13;&#10;Untitled picture.png uti &#10;values in arriving &#10;packet heade &#10;control &#10;plane &#10;data &#10;plane &#13;&#10;Data plane: determine how datagrame is routed from input port to outport port (e.g. Local router function, Forwarding functions)&#13;&#10;Control plane, Data plane&#13;&#10;Best-effort service: With best-effort service, packets are neither guaranteed to be received in the order in which they were sent, nor is their eventual delivery even guaranteed. There is no guarantee on the end-to-end delay nor is there a minimal bandwidth guarantee.&#13;&#10;Cost ==> Cheap&#13;&#10;Speed ==> fast&#13;&#10;congestion severity ==> mild&#13;&#10;Performance of routing&#13;&#10;Cost of path ==> Larger cost == small bandwidth == severe congestion&#13;&#10;e.g. Dijkstra's algorithm&#13;&#10;Question: How to find the least-cost path between two routers?&#13;&#10;Graph abstraction of the network:&#13;&#10;static: routes don't change or changes slowly over time&#13;&#10;Dynamic: routes change quickly (Don't cover in this course)&#13;&#10;Routing algorithm classification&#13;&#10;Both LS and DV are decentralized algorithm (distributed to each router in the path, instead of making decision by one)&#13;&#10;Need to have the information of entire map to run the Dijksta's algorithm&#13;&#10;determine the cost function (e.g. propagation delay, link capacity, and etc)&#13;&#10;Then every router know the cost to the node adjacent to them&#13;&#10;Link state advertisement&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;Control blame &#10;Comm link &#10;relayed pack &#10;control packets &#10;Route - 7 &#13;&#10;How does router know the cost of other router?&#13;&#10;Link state protocol &#13;&#10;Ink Drawings&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCFBD(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Machine generated alternative text:&#10;&#10;Control blame &#10;Comm link &#10;relayed pack &#10;control packets &#10;Route - 7 &#13;&#10;The control plane(The rouoting information/algorithm, i.e. entire topogy map) is stored at router and communicated through communication link.  &#13;&#10;Untitled picture.png th &#13;&#10;Untitled picture.png Dx(y) minv{c(x,v) + Dv(y)} for each node y E N &#10;Bellman-Ford equation &#13;&#10;What is difference from Bellman-Ford equation?&#13;&#10;Dijkstra's algorithm&#13;&#10;maintain its distance vector &#13;&#10;know cost to each neighbor&#13;&#10;So each router know the cost from itself to it's neighbor&#13;&#10;For each router in the path:&#13;&#10;Untitled picture.png b sends DV to a &#10;Take minimum &#10;of the two &#10;7 &#10;8 &#10;1 &#10;2 &#10;2 &#13;&#10;Distance vector protocal: Initialization stage&#13;&#10;" 
src="Lecture%20note_v3_files/mhtCFDF(1).tmp" width=1070 height=960><BR><IMG 
alt="Here d sends its DV to a&#13;&#10;there are two table, one is the old DV that a is maintaining, it has all the cost from a to its neighbors&#13;&#10;Second table is the DV from b + the cost(a, b), e.g. path from a->b->a == 7 + 7 = 14 , Cost(a->b->b) == 7, Cost(a->b->c) == 7 + 1 = 8&#13;&#10;Untitled picture.png b sends DV to a &#10;Take minimum &#10;of the two &#10;7 &#10;8 &#10;1 &#10;2 &#10;2 &#13;&#10;Broadcast link cost information to all nodes in the network, such that all nodes has a identical ad complete view of entire map and link costs.&#13;&#10;Run Dijkstra's algorithm to compute least cost path from node to all other nodes&#13;&#10;Update forwarding table based on resulting least cost paths.&#13;&#10;At each node&#13;&#10;Link state:&#13;&#10;It's a decentralized algorithm. (Contrast to Link state, a centralized algorithm)&#13;&#10;No like LS, for which need to know the information fo entire map. For DV, we run Bellman-ford algorithm, so each node maintains an estimate of its distance to all other nodes: called a distance vector. From time to time nodes share their distance vectors with their neighbors&#13;&#10;When a node receives a new distance vector from its neighbor, it updates its own distance vector&#13;&#10;The updated distance vector is then shared again with neighbors&#13;&#10;Distance vector&#13;&#10;The actual implementation were determined at Control plane (by network provider), but both has practical implementation in reality.&#13;&#10;For LS(link State), it use broadcast strategy, so every router has the infromation about entire network,whenever a new router added to the network, the topological graph at each router will be update. However, it can be substantially large to store the entire map of internet, so we have something called autonomous system(manage by local ISP), so every router only need to remember the Networking map of local region.&#13;&#10;For DV(distance Vectors), it use the local network strategy. So each router only need to maintain the distance cost from its neightbor, so whenever a new router added connect to it, the cost information will be updated.&#13;&#10;For LS, it use dijskra's algorithm. The Dijskra algorithm required the information of entire map before running it. However, for DV, we don't have the information about entire network, so we use Belllman-Ford algorithm.&#13;&#10;Untitled picture.png LS: &#10;• with n nodes, E links, O(nE) msgs sent &#10;• preferable for small networks &#10;• exchange between neighbors only &#10;preferable for large networks &#13;&#10;What is store d is difference &#13;&#10;runtime is idfferent&#13;&#10;What is different between two is it's initization step? One broadcast link cost to all nodes, so each router has information about every router in the network? Or Is there a central administrator to manage this &#13;&#10;Comparison of LS and DV algorithms&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD011(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png LS: &#10;• with n nodes, E links, O(nE) msgs sent &#10;• preferable for small networks &#10;• exchange between neighbors only &#10;preferable for large networks &#13;&#10;Untitled picture.png LS: &#10;• O(n2) &#10;may have oscillations &#10;• convergence time varies &#10;• may be routing loops &#13;&#10;runtime is idfferent&#13;&#10;Untitled picture.png robustness: what happens if &#10;router malfunctions? &#10;LS: &#10;• node can advertise incorrect link cost &#10;each node computes only its own &#10;table &#10;DV: &#10;• DV node can advertise incorrect path &#10;cost &#10;• each node's table used by others &#10;• error propagate thru network &#13;&#10;Can cause different malfunctions&#13;&#10;How to make the routing scalable?&#13;&#10;First, find a sequence of major city you need to travel through &#13;&#10;How would you plan a jouney from columbus to Boston?&#13;&#10;&#13;&#10;(Midterm1 Stop here….)&#13;&#10;routing among hosts and routers within the same AS.&#13;&#10;What is intradomain routing? &#13;&#10;Routing across AS(autonomous system)&#13;&#10;What is interdomain routing? &#13;&#10;To find a path between two entities within an autonomous system by optimizing on metrics such as distance etc&#13;&#10;What is the goal of an intradomain routing algorithm such as link-state or distance-vector routing? &#13;&#10;The goal is to ensures reachability. Discovering information regarding routing paths between domains and propagating that information to the internal routers within the domains.&#13;&#10;What is the goal of an interdomain routing algorithm like BGP? &#13;&#10;The goal of interdomain routing is to ensure the rechability, i.e. to ensure that theres is some path to get from one host on the internet to another. This is contrast to the intradomaing routing. With intradomain routing, the goal was to find a good path that optimize some performance or cost, e.g. lowest latency, highest bottleneck link capacity, etc. This is possible only in intradomaing routing, because all routers are under a single administrative control. Whereas, in interdomaing routing, the network communication have more complex policies connected between different AS, which usually based on the business logic and trust between their network administrator.&#13;&#10;Why are these goals different?&#13;&#10;HW4 Q4: Interdomain Vs Intradomain routing&#13;&#10;Network of routers controlled by single administrative, such as a univeristy, an enterprise company(i.e. Yahoo, Facebook), an Internet Service Provide(i.e. ATT, Spectrum), or a content provider(i.e. Googl, Netflix, or Facebook)&#13;&#10;Autonomous system(AS) -- 自治系统&#13;&#10;Means routing among hosts and routers within the same AS. All routers in same AS must run same intra-domain routing protocal, but router in different AS can run different intra-domain routing protocol, e.g. LS or DV.&#13;&#10;Intra-domain routing (Within a AS)&#13;&#10;2/19, Lecture 18: Networking layer: Control plan: Inter-domain routing&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD033(1).tmp" width=1070 height=960><BR><IMG 
alt="Means routing among hosts and routers within the same AS. All routers in same AS must run same intra-domain routing protocal, but router in different AS can run different intra-domain routing protocol, e.g. LS or DV.&#13;&#10;Means routing across different AS. The goal is to ensures reachability. The inter-domain communication is usually managed by BGP protocal, without the interdomain routing, as an OSU student, you won't be reach to the ourside world.&#13;&#10;Inter-domain routing (Between differnet AS)&#13;&#10;There can be as many gateway router as you want, and it's possible all the router in an AS are gateway router&#13;&#10;So the graph at the local ISP might be large, and the high-level graph can be sparse. So, the inter-AS routing was control by any machine or person, it's just determined by the Business model for different company. The administrative of AS can control it. &#13;&#10;What-is-Internets-Hierarchical-Structure-1024x683.jpg Image result for isp hierarchy&#13;&#10;There also can be as many AS as you want, but it's more expensive to make a direct connection to upper level ISP than the regional ISP.&#13;&#10;Inter-AS communication was managed by BGP advertisement, and intra-AS communication was managed by algorithm, either LS or DV.&#13;&#10;Q: What is the difference between Intra-AS routing protocol(e.g. LS, DV) and inter-AS routin protocol (e.g. BGP)?&#13;&#10;How many gateway router exist, and how many AS could exist?&#13;&#10;A border router is simply an IP router that is responsible for the task for forwarding packets between AS. F&#13;&#10;Border routers sit at the boundary of a domain and have a direct connection to another border router sitting&#13;&#10;at the boundary of an adjacent domain.&#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;AS - 4 &#10;AS- 6 &#10;AS 5 &#13;&#10;The Border gateway routers perfrom inter-domain as well as intra-domain routing&#13;&#10;Border routers (aka Gateway router)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD055(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Machine generated alternative text:&#10;&#10;AS - 4 &#10;AS- 6 &#10;AS 5 &#13;&#10;E.g. Those black routers at the edge of AS-1 are called gateway routers&#13;&#10;The predominant protocol for interdomain routing is the Border Gateway Protocol (BGP). This protocol is&#13;&#10;responsible for:  1)Discovering information regarding routing paths between domains ==> eBGP, and 2)Propagating this information to the internal routers within a domain. ==>iBGP In more detail, the first step is responsible for figuring out a sequence of domains that gets a packet from a source domain to a destination domain. The second step is responsible for telling an internal router in the source domain which border router it needs to send packets to so that the packets can eventually find their way to the destination.&#13;&#10;Untitled picture.png eBGP connection &#10;iBGP connection &#10;Gateway routers run &#10;both eBGP and iBGP &#13;&#10;Untitled picture.png Forwarding table entries &#10;dest &#10;x &#10;la,AS1, &#10;Forward to &#10;3b &#10;,x &#10;• &#10;AS 2 &#10;• 3a learns about X via iBGP from &#10;3c: &quot;path to X goes through 3c&quot; &#10;Use intra-domain routing to &#10;forward to 3c &#13;&#10;Path Advertisement is like &quot;Making promise&quot;. For example of following graph, when 2a sending the eBGP advertisement, 2a promise it has the infromation(routing info) to X. So, AS1 will use its own algorithm to compute a inter-AS routing path and extend the reachability information from X to next AS(i.e. AS-3)&#13;&#10;Based on eBGP protocal, 1b gateway/border router at the boundary of AS1 will tell(or promise) the gateway router 3c two things: 1)You can reach any IP address within AS1 by adding prefix (1b, AS1), 2)You can reach any IP address within AS2 by adding the sequence of domain predix (1b, AS1, AS2). &#13;&#10;How the information being exchanged between two AS via eBGP?&#13;&#10;The eBGP (for external BGP) protocol is responsible for obtain subnet reachability information from neighboring/external AS'es. Also known as &quot;path vector&quot; Protocol.&#13;&#10;The iBGP(internal BGP) is responsible for propagateing reachability information to the routers within/inside a AS&#13;&#10;What is the difference between eBGP and iBGP&#13;&#10;BGP(Border gateway protocol)&#13;&#10;&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD078(1).tmp" width=1070 height=960><BR><IMG 
alt="In short, eBGP say, &quot;Let's gather some useful data outside my house&quot;&#13;&#10;iBGP says, &quot;Wooo, delivers this fancy news to everybody in my family..&quot;&#13;&#10;The iBGP(internal BGP) is responsible for propagateing reachability information to the routers within/inside a AS&#13;&#10;After router 1d receives path prefix (2a, AS3, X) from router 2a (via eBGP).&#13;&#10;Based on AS1 policy, router 1d may accepts the path and propagates this reachability information to all AS1 routers (via iBGP) .&#13;&#10;Untitled picture.png BGP path advertisement &#10;1 ,ASI, &#13;&#10;Based on AS1 policy, router 1b can advertises the path prefix (1b, AS1, AS3, X) to router 3c(via eBGP).  Such that, the router 3c will know how to make connection to X. &#13;&#10;Let's see an example to how gateway router can learn tranmission path via BGP protocol, or how interdomain protocol works: (Say X want to send some package to 3c, and we need to find a way to make connection between them)&#13;&#10;Common BGP path advertisement process:&#13;&#10;Router 3c can learns about path prefix (AS1, AS2, X) from router 1a&#13;&#10;Router 3c can also learn another path predix (AS2, X) from 2a.&#13;&#10;Untitled picture.png BGP path advertisement &#10;la,AS1 2,X &#13;&#10;Based on their business policy, router 3c can choose either paths and advertises this reachability information within its AS via iBGP protocal.&#13;&#10;Gateway routers may learn multiple paths to destination as well, for example:&#13;&#10;Multiple path  BGP path advertisement delivery process&#13;&#10;Yes, it depends on Business model, or relationship between two AS, or company.&#13;&#10;Untitled picture.png (لا٤؟رA4٤18s5 &#10;Aszåsg &#10;ر &#10;ا &#10;ي &#10;6&quot; &#13;&#10;For example, there can be two way from AS1 to X. Even AS1-AS4-AS5…X has a cheaper cost, but not necessary the packet will be send in this way.  Because it's possible AS1 and AS5 are competitor, and they hate each other, so AS1 would choose another routing path (So he don't need to pay money to AS5 for inter-AS communication).&#13;&#10;Is possible there are two AS routing sequence that has same cost? if so, who will decide which routing path will be used? &#13;&#10;BGP path advertisement&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD0AA(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png (لا٤؟رA4٤18s5 &#10;Aszåsg &#10;ر &#10;ا &#10;ي &#10;6&quot; &#13;&#10;Untitled picture.png Machine generated alternative text:&#10;&#10;Customer &#10;just &#10;( ISPA &#10;Campus Network &#10;&#13;&#10;The administrator of Campus Network has absolutely control of next AS to share with. E.g. If Campus Network has a bad business relationship with ISP B, it can just block this information with ISP B.&#13;&#10;AS administrator policy decision&#13;&#10;Path visiting fewest number of AS'es&#13;&#10;Choose the path with smallest cost (intra-domain routing cost)&#13;&#10;If router learns about more than one route to destination AS, select route based on following three:&#13;&#10;BGP route selection&#13;&#10;&#13;&#10;IP address: 32-bit identifier for host, router interface &#13;&#10;Interface: connection between host/router and physical link&#13;&#10;IP addressing&#13;&#10;Subnet part: Higher order bit -- first 23 bit&#13;&#10;Untitled picture.png subnet &#10;part &#10;11001000 00010111 &#10;host &#10;part &#10;00010000 00000000 &#10;IP addr: &#10;200.23.16.0/23 &#13;&#10;Host part: Lower order bits -- last 9bit&#13;&#10;IP address (identical 32 bit)&#13;&#10;Subnets&#13;&#10;2/28: Slide18: Inter-domain routing&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD0CC(1).tmp" width=1070 height=960><BR><IMG 
alt='Untitled picture.png subnet &#10;part &#10;11001000 00010111 &#10;host &#10;part &#10;00010000 00000000 &#10;IP addr: &#10;200.23.16.0/23 &#13;&#10;Devices that interfaces with same subnet can physically reach each other without intervening router.&#13;&#10;the IP terms, a network interconnecting three host interfaces and one router interface form a subnet. IP addressing assigns an address to this subnet: 223.1.1.0/24, where the /24 ("slash-24") notation, sometimes known as a subnet mask, indicates that the leftmost 24 bits of the 32-bit quantity define the subnet address.&#13;&#10;Device interfaces with same subnet part in their IP address.&#13;&#10;Can physically reach each other without intervening router&#13;&#10;Share higher order bit IP address&#13;&#10;The 223.1.1.0/24 subnet thus consists of the three host interfaces (223.1.1.1, 223.1.1.2, and 223.1.1.3) and one router interface (223.1.1.4). Any additional hosts attached to the 223 .1.1.0/24 subnet would be required to have an address of the form 223.1.1.xxx. There are two additional subnets shown in Figure 4.18: the 223.1.2.0/24&#13;&#10;network and the 223.1.3.0/24 subnet.&#13;&#10;Untitled picture.png 223.1.1.2 &#10;2 3.1.2. &#10;1 &#10;2232129 &#10;223.1 .2 &#10;.1.3 223 . 27 &#10;223.1.3, &#10;subnet &#10;.1.3.2 &#10;network consisting of 3 subnets &#13;&#10;&#13;&#10;What is subnet: &#13;&#10;totally about 2^9 = 512 End-host can be contained within a subnet&#13;&#10;Untitled picture.png As &#10;sca...L71-Lt &#13;&#10;The last 9 bit will be wildcard, each 512 End-host will have different lower order bit within a subnet. &#13;&#10;Hierarchical addressing: Route aggregation (or Address aggregation)&#13;&#10;Use IPV6--128 bit &#13;&#10;Use private IP addresses -- requires network address translation&#13;&#10;Handling IP address shortage&#13;&#10;IP addressing&#13;&#10;' 
src="Lecture%20note_v3_files/mhtD0FE(1).tmp" width=1070 height=960><BR><IMG 
alt="Use private IP addresses -- requires network address translation&#13;&#10;Local address is not visible from outside world, they can change addresses of devices in local network without notifying outside world, but NAT is needed to implement this.&#13;&#10;Private IP addressing&#13;&#10;Untitled picture.png Internet &#10;138.76.29 &#10;all datagrams leaving local &#10;network have same single &#10;source NAT IP address: &#10;138.76.29.7,different &#10;source port numbers &#10;local n &#10;(e.g., home network) &#10;10.0.0.0/24 &#10;10.0.0.4 &#10;10.0.0.1 &#10;10.0.0.2 &#10;10.0.0.3 &#10;datagrams with source or &#10;destination in this network &#10;have 10.0.0/24 address for &#10;source, destination (as usual) &#13;&#10;E.g. we want to send a packet from Source: 10.0.0.1 to a Dest: 128.119.40.196, the router (managed by private network administrator) will have an NAT to convert our local addrsses to a public address, and it also can be used to hide user physical location.&#13;&#10;There is a NAT translation table will help us to translate the private IP address to public IP address within a subnet network. &#13;&#10;Outgoing datagrames(发出去的): replace (source IP addr, port #) of every outgoing datagram to (NAT IP addr, new port #)&#13;&#10;Remember in NAT translation table: Translation pair between Source (IP, Port#) and NAT(IP, Port#)&#13;&#10;Incoming datagrams(发进来的):  replace (NAT IP addr, new port #) of every incoming datagram to  (source IP addr, port #) &#13;&#10;Untitled picture.png NAT translation table &#10;2: NAT router &#10;changes datagram &#10;source addr from &#10;10.0.0.1, 3345 to &#10;138.76.29.7, 5001, &#10;updates table &#10;Public address &#10;Private address &#10;138.76.29.7, 5001 10.0.0.1, 3345 &#10;1: host 10.0.0.1 &#10;sends datagram to &#10;128.119.40.186, 80 &#10;S: 10.001, 3345 &#10;D: 80 &#10;S: 5001 &#10;D: 128.119_40.186, 80 &#10;138.76.29.7 &#10;S: 128.119.40.186, 80 &#10;3 &#10;D: 138.76.29.7 5001 &#10;3: reply arrives &#10;dest. address: &#10;138.76.29.7, 5001 &#10;10.0.0.4 &#10;s: 128.119.40_186, 80 &#10;D: 10.001, 3345 &#10;10.0.0.1 &#10;10.0.0.2 &#10;4 &#10;10.0.0.3 &#13;&#10;Example: Look close on how S and D addr changes from 1 to 2, and from 3 to 4:&#13;&#10;NAT implementation&#13;&#10;Network Address Translation(NAT) &#13;&#10;" 
src="Lecture%20note_v3_files/mhtD120(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png NAT translation table &#10;2: NAT router &#10;changes datagram &#10;source addr from &#10;10.0.0.1, 3345 to &#10;138.76.29.7, 5001, &#10;updates table &#10;Public address &#10;Private address &#10;138.76.29.7, 5001 10.0.0.1, 3345 &#10;1: host 10.0.0.1 &#10;sends datagram to &#10;128.119.40.186, 80 &#10;S: 10.001, 3345 &#10;D: 80 &#10;S: 5001 &#10;D: 128.119_40.186, 80 &#10;138.76.29.7 &#10;S: 128.119.40.186, 80 &#10;3 &#10;D: 138.76.29.7 5001 &#10;3: reply arrives &#10;dest. address: &#10;138.76.29.7, 5001 &#10;10.0.0.4 &#10;s: 128.119.40_186, 80 &#10;D: 10.001, 3345 &#10;10.0.0.1 &#10;10.0.0.2 &#10;4 &#10;10.0.0.3 &#13;&#10;Provides better Security&#13;&#10;Reduce the number of public IP address&#13;&#10;Advantage:&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;input port &#13;&#10;Router Architecture&#13;&#10;Untitled picture.png Destination Address Range &#10;11001000 &#10;11001000 &#10;11001000 &#10;otherwise &#10;00010111 &#10;00010111 &#10;00010111 &#10;00011000 &#10;00011 &#10;Link interface &#10;2 &#10;3 &#13;&#10;All above three are different public IP addr, but they have different range for their local addr. Some of them have 11 bit range(last 11 bit are differ for their local network addr), but some of them only have last 9 bit are differ&#13;&#10;Note: link Interface 1 is the subset/subnet of Link interface 2?&#13;&#10;Destination-base forwarding&#13;&#10;When there are multiple Dest addr you can match in forwarding table, you pick the Dest addr that has the longest prefix to forward. In short, match as many as possible!&#13;&#10;Untitled picture.png DA: 11001000 00010111 00010110 10100001 &#10;DA: '11001000 00010111 00011000 10101010 &#10;Interface O &#10;Interface I &#13;&#10;All implement in hardward, use the hash table to implement/ directly&#13;&#10;For example: (using the above Dest addr table)&#13;&#10;Untitled picture.png Organization O &#10;O ization 2 &#10;Organization 7 &#10;0023.30. &#10;O &#10;&quot;Send me anything &#10;with addresses &#10;beginning &#10;00.23.16.0/20&quot; &#10;IPBy-Night-lSP &#10;Internet &#10;&quot;Send me anything &#10;ISPS-R-US &#10;with addresses &#10;beginning 200.23.18.0/23&quot; &#10;anization 1 &#10;200.23.18.0/23 &#13;&#10;ISPs-R-Us has a more specific route to Organization 1, the addr of ****18.0** purchase by them, so the packet was send to ISPs-R-US&#13;&#10;Another example:&#13;&#10;Longest Prefix matching:  [reference, �HYPERLINK &quot;http://www.cs.toronto.edu/~ahchinaei/teaching/2016jan/csc358/Tut08-taSlides.pdf&quot;http://www.cs.toronto.edu/~ahchinaei/teaching/2016jan/csc358/Tut08-taSlides.pdf]&#13;&#10;3/4&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD142(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Organization O &#10;O ization 2 &#10;Organization 7 &#10;0023.30. &#10;O &#10;&quot;Send me anything &#10;with addresses &#10;beginning &#10;00.23.16.0/20&quot; &#10;IPBy-Night-lSP &#10;Internet &#10;&quot;Send me anything &#10;ISPS-R-US &#10;with addresses &#10;beginning 200.23.18.0/23&quot; &#10;anization 1 &#10;200.23.18.0/23 &#13;&#10;&#13;&#10;1)Can the transport layer rely on the network layer to deliver the packet to the destination? &#13;&#10;2)When multiple packets are send, will they be delivered in the order in which they were sent? &#13;&#10;3)Will the amount of time between the sending of two sequential packet transmissions be the same&#13;&#10;as the amount of time between their reception? -- 发送两个连续的包传输之间的时间是否与接收它们之间的时间相同? &#13;&#10;4) Will the network provide any feedback about congestion in the network?&#13;&#10;Motivation:&#13;&#10;Guaranteed delivery:This service guarantees delivery of the packet, such that a packet sent by a source host will eventually arrive at the destination host.&#13;&#10;Guaranteed delivery with bounded delay: This service not only guarantees delivery of the packet, but guarantess the delivery time is within a specified host-to-host delay bound (for example, within 100 msec).&#13;&#10;In-order packet delivery: This service guarantees that the orders packets arrive at the destination in the order that they were sent.&#13;&#10;Guaranteed minimal bandwidth: This network-layer service emulates the behavior of a transmission link of a specified bit rate (for example, 1 Mbps) between sending and receiving hosts. As long as the sending host transmits bits (as part of packets) at a rate below the specified bit rate, then all packets are gaurantee will be delivered to the destination host. 只要发送主机以低于指定比特率的速率传输比特(作为包的一部分)，那么所有的包最终都会被发送到目标主机.&#13;&#10;Security: The network layer could encrypt all datagrams at the source and decrypt them at the destination, thereby providing confidentiality to all transport-layer segments.&#13;&#10;What is Network service model: It defiens the characteristics of end-to-end delivery of packets between sending and receiving hosts:&#13;&#10;The Internet's basic best-effort service model combined with adequate bandwidth provisioning have arguably proven to be more than &quot;good enough&quot; to enable an amazing range of applications, including streaming video services such as Netflix and voice-and-video-over-IP, real-time conferencing applications such as Skype and Facetime.&#13;&#10;However, None of this services are guarantee in today Internet service. The Internet's network layer provides a single service, known as &quot;best-effort service&quot;.今天的互联网只保证一件是：我尽量 - -!&#13;&#10;Network Sevice model:&#13;&#10;3/6 Slide19: Networking layer: Data Plane: Switching fabric&#13;&#10;&quot;transport layer segments&quot; is defined as the packets in Transport layer&#13;&#10;&quot;datagram&quot; is defined as the packet in Network layer&#13;&#10;Segment Vs datagram&#13;&#10;Routing: Decide the overall route taken by packet from source to destination, or end-end-path through network(Control plane)&#13;&#10;Untitled picture.png Routing Algorithm &#10;Local Forwardin &#10;Header Value Out &#10;0100 &#10;0101 &#10;0111 &#10;1001 &#10;Table &#10;ut Link &#10;3 &#10;2 &#10;2 &#10;Routing algorithm determines &#10;end-end-path through network &#10;(control plane) &#10;Forwarding table determines &#10;local forwarding at this router &#10;(data plane) &#13;&#10;Forwarding: Decide which path to go in certain intersection/router, determine the local forwarding at this router.&#13;&#10;Routing Vs forwarding &#13;&#10;Networking Layer Vs Transport layer comparison: &#13;&#10;&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD155(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Routing Algorithm &#10;Local Forwardin &#10;Header Value Out &#10;0100 &#10;0101 &#10;0111 &#10;1001 &#10;Table &#10;ut Link &#10;3 &#10;2 &#10;2 &#10;Routing algorithm determines &#10;end-end-path through network &#10;(control plane) &#10;Forwarding table determines &#10;local forwarding at this router &#10;(data plane) &#13;&#10;Control plane: determine how datagrame is routed from Source host to Dest host (E.g. Network-wide logic, routing algorithm)&#13;&#10;Untitled picture.png ForwaMing tables computed, &#10;pushed to input ports &#10;o &#10;o &#10;Router input ports &#10;Routing &#10;proc ssor &#10;High-speed &#10;switching &#10;fabric &#10;Routing, management &#10;control plane (software) &#10;Forwarding data &#10;plane (hardware) &#10;Router output ports &#13;&#10;Data plane: determine how datagrame is routed from input port to outport port (e.g. Local router function, Forwarding functions)&#13;&#10;Control plane, Data plane&#13;&#10;Network/Routing layer: provide services between two hosts&#13;&#10;Transport layer: provide services between two processes on end-system&#13;&#10;Network vs. transport layer connection service:&#13;&#10;Forwarding data plane(includes input port, output port, and switching fabric) are almost always implemented in hardware, which support as extremly high speed data transfer.&#13;&#10;Goal: transfer packet from input port/buffer to appropriate output port/buffer&#13;&#10;Routing: It's a algorithm implemented in the control plane. The algorithm that calculate the path/route taken by packets as they flow from a sender to receiver.&#13;&#10;Untitled picture.png &#13;&#10;Forwarding is a more router-local action, and routing refers to a network-wide process that determines the end-to-end paths from source to destination. Analogy for this, the routing is like planing a trip from Pennsylvania to Florida, and forwarding is like the process of getting through a single interchange(交叉路口). &#13;&#10;What is difference between routing and forwarding? &#13;&#10;Forwarding: It's a function implemented in the data plane. When a packet arrices at a router's input link, the router must move the packet from input port to the appropriate output link.&#13;&#10;Terminology&#13;&#10;Switching fabric(交换结构)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD177(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;the physical layer function of terminating an incoming physical link at a router; this is shown in the leftmost box of an input port in Figure.它执行物理层功能，终止进入路由器的物理链路;&#13;&#10;An input port also performs link-layer functions needed to interoperate with the link layer at the other side of the incoming link; this is represented by the middle boxes in the input and output ports. 输入端口还执行与进入链路另一侧的链路层互操作所需的链路层功能; 这由输入和输出端口中的中间框表示&#13;&#10;Untitled picture.png line &#10;termination &#10;physical layer: &#10;bit-level reception &#10;data link layer: &#10;e.g., Ethemet &#10;lookup, &#10;link &#10;forwarding &#10;layer &#10;protocol &#10;(receive) &#10;queuelng &#10;decentralized switching: &#10;fabric &#10;• using header field values, lookup output port using &#10;forwarding table in input port memory &#10;• goal: complete input port processing at 'line speed' &#10;• queuing: if datagrams arrive faster than forwarding &#10;rate into switch fabric &#13;&#10;&#13;&#10;Perhaps most crucially, a lookup function is also performed at the input port (也许最重要的是，在输入端口也执行查找功能); this will occur in the rightmost box of the input port. It is here that the forwarding table is consulted to determine the router output port to which an arriving packet will be forwarded via the switching fabric.在这里，参考转发台来确定路由器的输出端口，到达的包将通过交换结构转发到路由器的输出端口。&#13;&#10;Input port: Three key functions performs at input port: &#13;&#10;Output port: 接受从Switching fabric 传来的packet，然后再传送到Pyhsical layer. An output port stores packets received from the switching fabric and transmits these packets to the outgoing link by performing the necessary link-layer and physical-layer functions. (Note: an output port will typically be paired with the input port on the same line card)&#13;&#10;Switching fabric: The switching fabric connects the router's input ports to its output ports. This switching fabric is completely contained within the router-a network inside of a network router!&#13;&#10;Switching rate: rate at which packets can be transferred from inputs to outputs buffer/port&#13;&#10;line rate: == transmission rate, link rate means capacity of incoming link&#13;&#10;Tick: The time that it takes to receive the smallest size packet on an input port or send the smallest size packet on an output port. (Two are typically equal, because input port and output port are connecting to the same cables)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD18A(1).tmp" width=1070 height=960><BR><IMG 
alt="line rate: == transmission rate, link rate means capacity of incoming link&#13;&#10;Tick: The time that it takes to receive the smallest size packet on an input port or send the smallest size packet on an output port. (Two are typically equal, because input port and output port are connecting to the same cables)&#13;&#10;Q: Where does the Switching fabric is implemented? ==> A router's inut port, output ports, and switching fabric are almost always implemented in hardware!&#13;&#10;Traffic signal&#13;&#10;4-way stop&#13;&#10;roundabout -- (交通）环岛&#13;&#10;Analogy of highway traffic policy implementation&#13;&#10;When every packet reached the memory pool, they shared memory. Only one comment queue sitting at switch.&#13;&#10;Bad:  This pool needs to support up to N enqueues per tick and up to N dequeues per tick so that the memory is sufficiently powerful to handle the worst case of a packet on each input and output port at every time tick. (See the following pictures, if the line rate is R pkt/s, you would need a NR pkt/s read/write speed for memory)&#13;&#10;Untitled picture.png memory &#13;&#10;Good: The ability to dynamically allocate more or less of the same memory to different output ports on demand. &#13;&#10;Switching via memory: Share Memory architecture&#13;&#10;If multiple packets arrive to the router at the same time, each at a different input port, all but one must wait since only one packet can cross the bus at a time. Because every packet must cross the single bus, the switching speed of the router is limited to the bus speed; in our roundabout analogy, this is as if the roundabout could only contain one car at a time. Nonetheless, switching via a bus is often sufficient for routers that operate in small local area and enterprise networks.&#13;&#10;Idea:  Instead of having one shared memory pool for all inputs and all outputs, we have N separate memories/queue buffer for each output port. Then each memory only needs to be powerful enough to support N enqueue and 1 dequeue per tick, &#13;&#10;Good: a considerable reduction in the number of operations per tick, comparing to Sharing pool architecture. (N read per tick can still be challenging some time)&#13;&#10;Untitled picture.png &#13;&#10;the IP index is determined by the forwarding label&#13;&#10;Bad: The downside is the memory can no longer be shared across output ports. Every output port is designed to have an exclusive memory dedicated to a particular output port alone, and that cannot be allocated for other output port, even you have one is in idle and the other is filling up(装满) with packets.&#13;&#10;Switching via a Bus (aka Output-queued swtich)&#13;&#10;Three types of switching fabric&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD1AC(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;This architecture requires N memory memories as well, but they only need to powerful enough to support 1 read/enqueue and 1 write/dequeue per tick.&#13;&#10;The property for cross bar(input-queue router): 1)Each input is connected to at most one output. 2)Each output is connected to at most one input. &#13;&#10;Thus, this problem can be formulated as a bipartite matching problem. However, solving this matching problem, with maximal match or maximum weight matching, is hard at the speeds of a router. &#13;&#10;imput port 1 -- output port 3&#13;&#10;imput port 2 -- output port 1&#13;&#10;imput port 3 -- output port 2&#13;&#10;you are only allow perfect matching, e.g. &#13;&#10;Untitled picture.png crossbar &#13;&#10;&#13;&#10;Crossbar(aka Input Queueing, The most popular one in real world application)&#13;&#10;Note: each round can only connect/transport 1 imput port to 1 output port&#13;&#10;Note: The number of input and output ports is typically the same, because there is only one physical port.&#13;&#10;==> Router manufacture, cost, currently technology trend&#13;&#10;Who actually decide the which switch policy to use? -->software? the router manufacture? &#13;&#10;==> crossbar&#13;&#10;Could you compare the difference between these three switching mechanism? Which has the best performance?&#13;&#10;&#13;&#10;&#13;&#10;Three type of switching pattern&#13;&#10;Review&#13;&#10;3/23 Slide19: Data plane (cont…)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD1CE(1).tmp" width=1070 height=960><BR><IMG 
alt="Output-queued swtich: memoery being queued at output port(there are input and output port)&#13;&#10;Untitled picture.png dic &#10;mem &#10;memo &#13;&#10;yellow: link layer packet, encapsuluate the packet, e.g. link layer header&#13;&#10;Red: networking layer, has forwarding table&#13;&#10;the link layer at output port, conver data to ananlog signal for physical layer&#13;&#10;the queueing can happen either input or output port&#13;&#10;Input-queured switches: the packet being queued at input port&#13;&#10;Shared memoery &#13;&#10;all the packet have to go to input port 1, when three packet arrived. When we are looking at the queue at output port 1, the buffer need to be able to support 1 read and N write in worse case.&#13;&#10;Untitled picture.png &#13;&#10;Compare to Sharing memory architecture: When there are n packet arrive at input port, the Share memory need to be fast enough to support N reads and N write at a time. So shareing memory architecture need to have a high speed switch, which can be very hard to do.&#13;&#10;What is the advantage of bus over others&#13;&#10;Bus&#13;&#10;Untitled picture.png &#13;&#10;Crossbard&#13;&#10;Three type of switching pattern&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD1E1(1).tmp" width=1070 height=960><BR><IMG 
alt="The most popular implementation in real world&#13;&#10;Bus is output queued switch, and crossbar is input queued switch(It only allow to match one switch at a time slot, you cannot match two input port to same output port at a time!)&#13;&#10;You can have different configuration at different time, but only one packet can be send to one output port at a time, so it's limited by the configuration&#13;&#10;only need to fast enough to support 1 read &amp; 1 write in any case. e.g. In worst case, 3 packet arrive that need to deliver to output port 1, &#13;&#10;Untitled picture.png &#13;&#10;Untitled picture.png 0 &#10;0 &#10;ー 0 冖 ノ &#13;&#10;because we are using FIFO technique, so it must wait until all packet in front of it get clear. it's known as Head-of line blocking. &#13;&#10;Q: If another packed had arrived at input port 2, destined for output 3, why wouldn't it switch the two packets, so its not just sitting there doing nothing? &#13;&#10;Queuing problem for cross-bar switch&#13;&#10;Idea: Every input port has memory that is organized as FIFO with one enqueue and one dequeue per tick. At evrey tick, an output&#13;&#10;What is HOL blocking? -->  queued datagram at front of queue prevents others in queue moving forward&#13;&#10;The green packet doesn't do anything useful, so it has to wait until the red datagram get transferred. &#13;&#10;This problem drop the capacity significantly on the line rate&#13;&#10;Example:&#13;&#10;Head-of-the-Line(HOL) Blocking: &#13;&#10;" 
src="Lecture%20note_v3_files/mhtD203(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png switch/ &#10;fabriÅ &#10;output port contention: &#10;only one red datagram can be &#10;transferred. &#10;lower red packet is blocked &#13;&#10;Q:  Suppose input port 2 is connected to output 3 and input port 3 is connected to 2. Is that still HOL blocking if there is no actual connection from input port 3 to output port 3? ==> No, it's not&#13;&#10;This problem drop the capacity significantly on the line rate&#13;&#10;Untitled picture.png 3 VOQS at each input port &#10;packets destined to output port I &#10;packets destined to output port 2 &#10;packets destined to output port 3 &#10;Outp ut port 1 &#10;Outp ut port 2 &#10;swnch &#10;fabric &#10;Outp ut port 3 &#13;&#10;Maintain three input virtual queue(FIFO policy) at a time, each queue was destine to certain outport port. With this VOQ, the capacity can be bring the capacity back to 100%&#13;&#10;Virtual Output Queue(VOQ): Maintain N separate queues for each input port, based on destination port of packet&#13;&#10;We call it VOQ is because the packet are destine to ourport, the input port is actually input port, and we are trying to minimize the number of packet queued at input!&#13;&#10;So, how possible this problem was being solve in real world?&#13;&#10;Untitled picture.png packet &#10;arrivals &#10;queue &#10;(waiting area) &#10;link &#10;(server) &#10;packet &#10;departures &#13;&#10;FIFO: transmit packets in the same order as they arrived -- No guarantee whatsoever.&#13;&#10;Priority scheduling: Sending the packet based on the their priority. When a flow of higher priority packet exists, send it before flow of lower priority. May end p starving some flows, not really fair, but useful when you want to prioritize certain type of traffic.&#13;&#10;Goal: Understanding What is scheduling policy? --> Deciding what is the most appropriate way to match the connection between input port and output port at next time slot! Usualy it depends on the number of packet are waiting at VOQ. If there are more packet, you would like to give it a high priority in switch. The job of packet scheduling is to decides which packet to transmit next from among the queued packets. There are three common scheduling policy for output queue:&#13;&#10;Scheduling policy: Packet Scheduling&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD216(1).tmp" width=1070 height=960><BR><IMG 
alt="Priority scheduling: Sending the packet based on the their priority. When a flow of higher priority packet exists, send it before flow of lower priority. May end p starving some flows, not really fair, but useful when you want to prioritize certain type of traffic.&#13;&#10;Can possibly achieve 100% throughput&#13;&#10;Untitled picture.png &#13;&#10;Untitled picture.png &#13;&#10;The dumpest way is to looking all the possible match, and find the max weight (If tie, just pick arbitrary)&#13;&#10;Idea: Draw a bipartite graph, find a match such that total weight of match in the graph is maximum. For example of the following graph, the best match would has a max weight: 2 + 2 + 3 = 7&#13;&#10;Time slot: Time it take to send one packet from input port to output port&#13;&#10;There are many other scheduling policy: Maiximum algorithm, througput optimality, there are hundreds of work had done, so ask google!&#13;&#10;Weighted fair scheduling: Lets specify the weights percentage.&#13;&#10;Untitled picture.png high priority queue &#10;(waiting areå) &#10;arri als &#10;departures &#10;classify &#10;link &#10;l?YPnontygueeervjer) &#10;(waiting area) &#13;&#10;Weighted fast scheduling: taking the pakcet who has a higher weight, the pencentage is change dynamically! (Based on the amount of packet in their waiting area_&#13;&#10;Some variation:&#13;&#10;Max weight scheduling&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD238(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png high priority queue &#10;(waiting areå) &#10;arri als &#10;departures &#10;classify &#10;link &#10;l?YPnontygueeervjer) &#10;(waiting area) &#13;&#10;&#13;&#10;Idea: you cicle those matching repeatively. Has no priority, sending packet in Round Robin fashion, taking one packet from high priority queue and taking one from low priority, and so on and so forth.&#13;&#10;Untitled picture.png &#13;&#10;So it's a more fair, uniformly draining the packet for each VOQ(virtual output queue)&#13;&#10;Pyhsically, input and output port are siting in same line card, so the total number of input port is equal to the total number of output port&#13;&#10;Q: Does it necessary to have the same number of input port and output port?&#13;&#10;Round Robin Scheduling&#13;&#10;[Reference]: �HYPERLINK &quot;http://www2.ic.uff.br/~michael/kr1999/6-multimedia/6_06-scheduling_and_policing.htm&quot;http://www2.ic.uff.br/~michael/kr1999/6-multimedia/6_06-scheduling_and_policing.htm&#13;&#10;It won’t wait buffer get full, instead, it will drop the packet before buffer get full, aka proactively dropping technique&#13;&#10;Instead of reacting after the fact congestion had happen, the ECN technique can proactively start to taking the action, marking the packet, the notify end-host the buffer is about to host, to slow the transmission rate or window size.&#13;&#10;or another technique is called ECN (explicity congestion notification): So when the buffer filled about 90%, we will mark the packet that is about getting full&#13;&#10; --> Why do we want to do that? 1)To control the size of buffer. Dropping packet is bad, so it good to have a better control of how to transmitting packet from input port to output port. 2)to avoid the synchronization problem. &#13;&#10;Active Queue Management(AQM): If the packet overflow in queue, the scheduler will take action proactively. ----Not on exam&#13;&#10;Untitled picture.png 32 bits &#10;IP protocol version &#10;number &#10;&quot;type&quot; of data &#10;header length &#10;(bytes) &#10;max number remaining hops &#10;(decremented at each router) &#10;upper layer protocol &#10;to deliver payload to &#10;head. type of &#10;ver &#10;service &#10;time to &#10;upper &#10;la er &#10;live &#10;length &#10;header &#10;total datagram &#10;length (bytes) &#10;32 bit source IP address &#10;32 bit destination IP address &#10;data &#10;(variable length, &#10;typically a TCP &#10;or UDP segment) &#13;&#10;Data(payload): contains the Transport-layer sement, and other type of data, e.g. ICMP message…. So, when the data comes down from transport layer, you're going to add a network layer header to the packet, which is everything on the top of data.&#13;&#10;IP datagram format (example of IPv4 datagram)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD24B(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png 32 bits &#10;IP protocol version &#10;number &#10;&quot;type&quot; of data &#10;header length &#10;(bytes) &#10;max number remaining hops &#10;(decremented at each router) &#10;upper layer protocol &#10;to deliver payload to &#10;head. type of &#10;ver &#10;service &#10;time to &#10;upper &#10;la er &#10;live &#10;length &#10;header &#10;total datagram &#10;length (bytes) &#10;32 bit source IP address &#10;32 bit destination IP address &#10;data &#10;(variable length, &#10;typically a TCP &#10;or UDP segment) &#13;&#10;Version number: Because different version of IP use different datagram format, e.g. IPV4, IPV6…These 4 bit number can determine how to interpret the remainder of IP datagram. &#13;&#10;Header Length:  The length of IP header. Because an IPv4 datagram can contain a variable number of options, these 4 bit are needed to determine where in the IP datagram the payload actually begins,. &#13;&#10;Type of service: The type of service (TOS) bits were included in the IPv4 header to allow different types of IP datagrams to be distinguished from each other. e.g. telephony application is a real-time service, which is different from non-real-time level of service, such as FTP. Therefore we can use it on the priority scheduling.&#13;&#10;Datagrame Length: The length of the IP datagram (header plus data), measured in bytes.&#13;&#10;(The blank aread in the middle)Identifier, flags,fragmentation offset: These three fields have. to do with so-called&#13;&#10;IP fragmentation, a topic we will consider shortly. Interestingly, the new version of IP, 1Pv6, does not allow for fragmentation.&#13;&#10;Untitled picture.png &#13;&#10;Time to live: The time-to-live (TTL) field is included to ensure that datagrams do not circulate forever (due to, for example, a long-lived routing loop) in the network. e.g. let it be 100 TTL. the value will decrement by one for each router had touched, and when the TTL get to zero, we will stop forwarding the packet. But if there is bug in your algorithm, you don't want the packet to keep cycling forever. &#13;&#10;Upper layer: help to decide what is the upper layer protocol that this data is come from, such as TCP or UDP in transport layer.&#13;&#10;Header checksum: detect the bit erroors in a received IP datagram. The header checksum is computed by treating each 2 bytes in the header as a number and summing these numbers using 1s complement arithmetic.(Discuss previously)&#13;&#10;Source and Dest IP: Those are very important because, as we say, the router use them to consult the longest prefix matching and decide what's the appropriate outport port to forward the packet to. The source Ip address is also important, so when the client/host received packet and return the acknowledgement back, so it know where the message should send to.&#13;&#10;&#13;&#10;Node: Let's call hosts and routers as nodes. Generally, it means any device that runs a link-layer protocol, such as hosts, routers, switches, and WiFi access points. &#13;&#10;Wired links: Ethernet, fiber, coaxial cable&#13;&#10;Wireless link: cellar tower, Wifi, satellite&#13;&#10;LAN&#13;&#10;link is the channels that connect adjacent nodes along the communication path, e.g. Wired link---Ethernet, fiber, optical cable, wireless links -- cellular, WIFI, satellite. A link is bidirectional, an output port will typically be paired with input port on the same line card(接口卡)!&#13;&#10;Framing: A frame consist of a data field, in which the network-layer datagrame is inserted, and a number of headers fields. Almost all link-layer protocols encapsulate each network-layer datagrame within a link-layer frame before transmission over the link. &#13;&#10;Definition&#13;&#10;(45:10 - end)3/30 Slide 20: Link Layer&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD25D(1).tmp" width=1070 height=960><BR><IMG 
alt='Transport layer: the packet is called segment&#13;&#10;Networking layer: the packet is called datagram&#13;&#10;Link layer: the link-layer packet is called frame&#13;&#10;Analogy to other network layer:&#13;&#10;Framing: A frame consist of a data field, in which the network-layer datagrame is inserted, and a number of headers fields. Almost all link-layer protocols encapsulate each network-layer datagrame within a link-layer frame before transmission over the link. &#13;&#10;point-to-point links that have a single sender at one end of the link and a single receiver at the other end of the link. e.g. the link between Ethernet switch and host. There are many link-layer protocols have been designed for point-to-point link, e.g. point-to-point protocol(PPP), and high-level data link control (HDLC).&#13;&#10;Point-to-point: &#13;&#10;Broadcast link have multiple sending and receiving nodes all connected to the same, single, shared broadcast channel. In practice, hundres or event thousands of nodes can directly communicate over a broadcast channel. More common in wireless link, e.g. 802.11 wireless LAN, WiFi, cellphone tower, and etc, but also possible in wire cable (e.g. Ethernet) So, when a node send a packet, everyone in the range could "heard"/have access to it. &#13;&#10;The protocol for shared broadcast link is called mutiple access protocols. &#13;&#10;Untitled picture.png shared wire (e.g., &#10;cabled Ethernet) &#10;shared RF &#10;(e.g., 802.11 WiFi) &#10;shared RF &#10;(satellite) &#10;humans at a &#10;cocktail party &#10;(shared air, acoustical) &#13;&#10;However, when mutiple nodes share a single broadcast link--the so-called multiple access problem. Here, the MAC protocol serves to coordinate the frame transmissions of the many nodes.&#13;&#10;Broadcast&#13;&#10;Two types of "links access"&#13;&#10;Link access: If link shared between multiple users(e.g. WiFi), a MAC(medium acess control) protocal can specifies the rules by which a frame is transmitted onto the link. &#13;&#10;Software: funcitons like Identifying the correct MAC address should be received, are implemented in OS(Operation System) as software&#13;&#10;Untitled picture.png &#13;&#10;Hardware: functions like, error bit checking, or decoding algorithm are happened in hardware.  The pyhsically layer is also implemented at NIC(Network interface card), e.g. convert the signal to voltage or electromagnetic wave and send out to the wire. &#13;&#10;Part of software part of hardware, but most of link-layer functionality is implemented in hardware, the link layer is implemented in a network adapter(网络适配器), also known as a network interface card(NIC, 网卡).&#13;&#10;Where is the link layer implemented&#13;&#10;' 
src="Lecture%20note_v3_files/mhtD27F(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;Untitled picture.png controller &#10;sen Ing os &#10;frame &#10;• Sending side: &#10;• Encapsulate datagram in frame &#10;• Add error checking bits, reliable &#10;data transfer etc. &#10;controller &#10;IVIng &#10;data ram &#10;• Receiving side: &#10;• Look for errors, reliable data transfer &#10;etc. &#10;• Extract datagram, and pass to upper &#10;layer &#13;&#10;Adaptors communication&#13;&#10;The link-layer has the responsibility of transferring packet from one nodes/hops to its adjacent node. Links can be between end host and  first hop router, or between two IP hops in the core. Different link layer technologies are united by IP. Link layers run on many different physical media. Examples: Ethernet over copper or fiber, wireless, long distance fiber links.&#13;&#10;What is the responsibility/main functions of link-layer?&#13;&#10;Application --> When packet reached Transport layer, transport layer will encapsulate a TCP header to Data --> Routing layer will add an IP header -->  Link layer will add the link layer header to Data, aka Frame&#13;&#10;Why do we need frame (link-layer header)?&#13;&#10;Includes MAC address(Medium access control) -- Src and Dest MAC addr. It's same like routing header includes both Src and Dest Ip addr&#13;&#10;What exactly was included in link-layer header? &#13;&#10;because if there are multiple user sharing the networking, that might cause the collision!&#13;&#10;Why cannot directly convert to voltage, meganetic wave?&#13;&#10;Reveiver is getting confused when multiple sharing happens, it cannot distinguish the packet come from which sender. &#13;&#10;So this should become the job of link layer. It should only allow one people talking at a time, so let's discuss some solution of how to solve this collision problem. &#13;&#10;Untitled picture.png &#13;&#10;Problem of collision in the past (Connected by ethernet)&#13;&#10;Framing: encapulates IP datagrame into a frame. When packet goes down from networking layer, a link layer packet(frame) will be added to the IP datagrame.&#13;&#10;MAC(Medium access): IP address is for router, and MAC is for Identify the end-point devices in link level &#13;&#10;So, in this case, if multiple user access to a shared communication medium simultaneiously, the MAC protocal could take care this collision problem&#13;&#10; Link access(连接访问): If link shared between multiple users(e.g. WiFi link), a MAC(medium acess control) protocal can specifies the rules by which a frame is transmitted onto the link. &#13;&#10;There are four major Link Layer services: 1)Framing, 2)Link access, 3)error correction, and 4)reliable delivery between adjacent nodes)&#13;&#10;Link Layer services:&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD292(1).tmp" width=1070 height=960><BR><IMG 
alt="So, in this case, if multiple user access to a shared communication medium simultaneiously, the MAC protocal could take care this collision problem&#13;&#10;Untitled picture.png &#13;&#10;The shared communication media includes WiFI networks, where EM waes belonging to a certain frequency range (2.4 to 2.48 GHz) are reserved for WiFi communication. Regardless of how many users are in a particular room, the same 80 MHz range (2.4–2.48 GHz) must be shared across all these users in some manner.&#13;&#10;The squared one at the right is Router(has all the IP forwarding table). It's the one that has IP forwarding table, and others in the left are Ehternet switches, which is the most popular implementation right now.&#13;&#10;Untitled picture.png &#13;&#10;In link-layer, ethernet switch don't understand the IP address, have no idea about the forwarding table, or even anything about other layer, such as TCP header. So, they only can use the frame(MAC addres) to deliver the packet to the nearest router, and the router will consult it's forwarding table and decided where the packet should be send to next hop.&#13;&#10;How does frame was being used to send the packets?&#13;&#10;Some popular techniques, e.g. parity bits, checksum, or CRC(Cyclic Redundancy Check) to detect bit error in received frame. &#13;&#10;There are errors caused by signal attenuation, noise. Receiver need to identifies and corrects bit errors without resorting to retransmission. &#13;&#10;Untitled picture.png &#13;&#10;Link layer switch, or Ethernet switch&#13;&#10;it's different from error detection, e.g. checkum&#13;&#10;error correction is more complicate task than detection. Error usualy can be caused by signal attenuation, and noise. After the error was detected, the receiver &#13;&#10;The error correction data has it's limit on how many bit can correct(if has some flip bit error)&#13;&#10;Error correction&#13;&#10;Error detection, correction, and recovery techniques&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD2B4(1).tmp" width=1070 height=960><BR><IMG 
alt="The error correction data has it's limit on how many bit can correct(if has some flip bit error)&#13;&#10;there is trader off between the number of bit of error correction you includes and the robustness of correction(decoding scheme)&#13;&#10;The more error correction you includes the more robust of you link layer deliver, if more than &#13;&#10;network interface card, that connect to your mother chip&#13;&#10;Because all those lin layer service are implement in hardware&#13;&#10;You cannot affor all those heavy cost computation in software. &#13;&#10;Why not inlcudes the error correction data in transport layer?&#13;&#10;The link-layer protocol only provide the reliability in a local level, e.g. you can make sure the packet can be transmitted between two router, but you don’t have a end-to-end reliability, which is the job of Transport layer to make sure the packet can be transmitted between end-host.&#13;&#10;Untitled picture.png &#13;&#10;e.g What if there is one router along the path have corruption, or break? In this time, if we still have the reliabilty from transport layer (Not routing layer?), we can make a detour to the destination, and avoidng the constantaneous packege dropping!&#13;&#10;Why do we need both link-level and end-to-end realibility? If you have the reliability in link-layer, why do you still need the reliability in Transport layer?&#13;&#10;Reliable delivery between adjacent nodes&#13;&#10;We are all familiar with the notion of broadcasting--television has been using it since its invention. We are all familiar with the notion of broadcasting-television has been using it since its invention. But traditional television is a one-way broadcast (that is, one fixed node transmitting to many receiving nodes), while nodes on a computer network broadcast channel can both send and receive. &#13;&#10;Perhaps a more apt human analogy for a broadcast channel is a cocktail party, where many people gather in a large room (the air providing the broadcast medium) to talk and listen. A second good analogy is something many readers will be familiar with-a classroom-where teacher(s) and student(s) similarly share the same, single, broadcast medium. &#13;&#10;However, there is one central problem. Because we allow all nodes(or end devices) are capable of trasmitting frames at the same time, then all of the nodes can receive multiple grames at the same time as well, and that's when collision happens. When there is a collision, the signals of the colliding frames become inextricably tangled together, and the broadcase channel is wasted, like the interference of ripple in a pond.&#13;&#10;In a home networking, we allow multiple users sending packets to a share WiFi router. When two or more devices/nodes are transmitting simultaneously, the Collision could happen. Therefore, we want to design a mechanism to avoid the collision when multiple devices broadcasting the signal.&#13;&#10;Untitled picture.png &#13;&#10;Motivation: &#13;&#10;MAC (Multiple access protocols, or Medium Access control protocol)&#13;&#10;" src="Lecture%20note_v3_files/mhtD2C7(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;Untitled picture.png &#13;&#10;When the receiver listening the signal from two device in a same time, there may have some overlapping and may confuse the receiver. Consider the example of a pond:&#13;&#10;Single shared broadcast channel. e.g. Multiple usre sending the packet to a shared WiFi router.&#13;&#10;So we need a distributed algorithm(no master node/administrator devices) that determines how the channel is shared by nodes, or when nodes can/cannot transmit packets/frame.&#13;&#10;e.g. your lap must use the home-Wifi network for coordination&#13;&#10;No out-of-band channel for coordination&#13;&#10;&quot;in-band&quot; communication: All devices are talking/communicating within a same netowork provider.&#13;&#10;It means that the communication of any control messages between the nodes, that may be required in the MAC protocol, must happen over the network itself and not through a separate communication link(network ISP). This is called &quot;in-band&quot; communication. If the nodes are in separate location (service provided by differnet ISP), dedicated communication links available to exchange the MAC protocol's control messages it is called &quot;out-of-band&quot; communication. &#13;&#10;E.g., in the Aloha protocol when a collision happens, the receiver communicates to the senders that a collision has happened through the same network. This is in-band communication. &#13;&#10;Instead, if the receiver had separate low-capacity wired links to the senders just for sending such control information, that would be called out-of-band communication. &#13;&#10;&quot;out-of-band&quot; communication: The devices are communicate across different network ISP, e.g. one in China, other end is in US&#13;&#10;In-band Vs Out-of-band communication&#13;&#10;Communication about channel sharing must use channel itself!&#13;&#10;Understand the problem so far: &#13;&#10;The networking layer is used to determing the S/D between two host/router), not for the Link-layer. And, you do want to have a decentralized mechanism(no master node/administrator devices), such that the link-layer can identify the device without depending on other layer protocol. &#13;&#10;Note1: remember the functions of link layer is to transport the IP datagram between two IP hops, it can be either between end-host and first hop router, or between two IP hops in the core&#13;&#10;Note2: Also, Link layer has no idea about the IP addr, consider it as the packet you want to deliver, so don't open it!!&#13;&#10;Consider the encapsulation mechanism, in link-layer, ethernet switchs have no idea about the forwarding table, or even anything about other layer, such as TCP, or HTML protocol. So, they only thing can use to deliver the packet to the nearest router is the frame(MAC addres).&#13;&#10;IP addrs is for networking layer, and MAC addr is for Link layer, and link layer shouldn't know anything about networking layer or IP address.&#13;&#10;Why do we need both IP addr and MAC addr? &#13;&#10;MAC adddresss are unique and fixed across all adapters (like SSN).&#13;&#10;One interesting property of MAC addresses is that no two adapters have the same address. How does a company manufacturing adapters in Taiwan make sure that it is using different addresses from a company manufacturing adapters in Belgium? The answer is that the IEEE manages the MAC address space. In particular, when a company wants to manufacture adapters, it purchases a chunk of the address space consisting of 224 addresses for a nominal fee. An adapter's MAC address is analogous to a person's social security number, and an IP address is analogous to a person's postal address. As a person moves, his postol adddr will changes but his security number remain fixed permanently. Just as a person may find it useful to have both a postal address and a social security number, it is useful for a host and router interfaces to have both a network-layer address and a MAC address.&#13;&#10;MAC addresses are 48 bits long.&#13;&#10;Property:&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD2E9(1).tmp" width=1070 height=960><BR><IMG 
alt="One interesting property of MAC addresses is that no two adapters have the same address. How does a company manufacturing adapters in Taiwan make sure that it is using different addresses from a company manufacturing adapters in Belgium? The answer is that the IEEE manages the MAC address space. In particular, when a company wants to manufacture adapters, it purchases a chunk of the address space consisting of 224 addresses for a nominal fee. An adapter's MAC address is analogous to a person's social security number, and an IP address is analogous to a person's postal address. As a person moves, his postol adddr will changes but his security number remain fixed permanently. Just as a person may find it useful to have both a postal address and a social security number, it is useful for a host and router interfaces to have both a network-layer address and a MAC address.&#13;&#10;Everytime we want to pass througth this &quot;Giant blue cloud&quot;,network switch, the link-layer will resolve the MAC address and IP address, and decide the the next hop to go.&#13;&#10;Untitled picture.png MAC src: 74-29-9C-E8-FF-55 &#10;MAC dest: E6-E9-OO-17-BB-4B &#10;IP src: 111.111.111.111 &#10;IP dest: 222.222.222.222 &#10;Eth &#10;Phy &#10;111.111.111.111 &#10;74-29-9C-E8-FF-55 &#10;111.111.111.112 &#10;CC-49-DE-DO-AB-7D &#10;Eth &#10;Phy &#10;222.222.222.220 &#10;IA-23-F9-CD-06-9B &#10;111.111.111.110 &#10;E6-E9-OO-17-BB-4B &#10;222.222.222.222 &#10;49-BD-D2-C7-56-2A &#10;222. 22.222.221 &#10;88-B2-2F-54-1A-OF &#13;&#10;Untitled picture.png 11 一 .111 一 111 , 111 &#10;A &#10;111 」 一 1 - 111 」 一 2 &#10;2222222 222 &#10;: 一 」 11 1 二 - 1 &#10;222 一 222 2 - 0 &#10;222 2 222-221 &#10;49 甶 0 • 02 • G7 24 &#10;B &#13;&#10;E.g. If node A want to send a message to node B, node A will be the starting point, and router R will be the next hop, and node B will be the final stop. In link-layer, node A will encapsulate the Link-layer frame with src/dest MAC addrress. When the packet reached the router R (via broadcast, the IP datagrame will be broadcast in the channel), it will decapsulate the frame. Now, we are in routing-layer. Router will consult its forwarding table with the src/dest IP addr and determine where is the next hop the packet should be send to. In the sender interface, router R will also encapsulate a new src/desc MAC address(but src/dest IP addr don't changes), and so on and so forth, until the packet reached destination.&#13;&#10;Implementation:&#13;&#10;Untitled picture.png &#13;&#10;Each devices have a unique MAC addr, and when a node send out its link-layer frame, each adjacent nodes can compare its MAC addr and the Dest Addr that nodes send out. If they match, the packet will be received, otherwise, the packet will be dropped.&#13;&#10;How does router know which device is the one that A wanna send to? Or How MAC is being used in this example? （比如说，在这个broadcast environment，我怎么知道这个信号是不是发给我的？其他的device也可以收到吗?)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD2FC(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;Note: In MAC addr routing, only the end deviced has MAC address but switch don't, and the switch don't have the concept of &quot;forwarding table&quot;. So how does switch know where the frame should be send to? ==> With the help of ARP(Address resolution protocol), which don't cover in this class.&#13;&#10;&#13;&#10;One node can transmit at a throughput/rate of R bps.&#13;&#10;M nodes can transmit at average rate of R/M &#13;&#10;The protocol is decentralized; that is, there is no master node that represents a single point of failure for the network. (E.g. No special node to coordinate the transmission; No synchronization of clocks, slot)&#13;&#10;Untitled picture.png &#13;&#10;Note: Those goals are pretty similar to the TCP &#13;&#10;The protocol is simple to implement&#13;&#10;Goals/Ideal properties/characteristics we want to achived&#13;&#10;Devide channel into smaller &quot;pieces&quot;&quot; &#13;&#10;So, no matter if a node has a packet to send or not, the channel will preserved this time slot for it.&#13;&#10;Untitled picture.png &#13;&#10;Allocate piece to node for exclusive use, kinda like circuit switching&#13;&#10;Channel partitioning protocol (e.g. TDMA, FDMA)&#13;&#10;When a node has something wanna to send, it doesn't care whether has something to send, instead, it will just go ahead and transmit the packet.&#13;&#10;Channel not divided, it allow collision.&#13;&#10;It allows the collision to happen, but it has way to detect it and recover from collision. &#13;&#10;When there is a collision, each node involved in the collision repeatedly retransmits its frame (that is, packet) until its frame gets through without a collision. But it doesn't necessarily retransmit the frame right away. Instead it waits a random delay before retransmitting the frame.&#13;&#10;&quot;recover&quot; from collision&#13;&#10;Random access protocol (e.g ALOHA, CDMA/DC)&#13;&#10;There are dozons of MAC protocol, but we can classify them to one of Three categories: &#13;&#10;4/3 Slide 20:  Data Link-layer cont…&#13;&#10;" src="Lecture%20note_v3_files/mhtD31E(1).tmp" 
width=1070 height=960><BR><IMG 
alt="When there is a collision, each node involved in the collision repeatedly retransmits its frame (that is, packet) until its frame gets through without a collision. But it doesn't necessarily retransmit the frame right away. Instead it waits a random delay before retransmitting the frame.&#13;&#10;Because the random delays are independently chosen, it is possible that one of the nodes will pick a delay that is sufficiently less than the delays of the other colliding nodes and will therefore be able to sneak its frame into the channel without a collision.&#13;&#10;Nodes take turns, but nodes with more to send can take longer turns&#13;&#10;&quot;taking turns&quot; protocol (e.g. polling, token-passing)&#13;&#10;&#13;&#10;Untitled picture.png 4KHz &#10;TOM &#10;Slot &#10;Key: &#10;Link &#10;Frame &#10;slots labeled &quot;2' ace dedicated &#10;to a specifir_ sender-receiver pair. &#10;Figure 6.9 • A four-node TDM and FDM example &#13;&#10;TDM divides time into time frames and further divides each time frame into N time slots. (The TDM time frame should not be confused with the link-layer unit of data exchanged between sending and receiving adapters, which is also called a frame. In order to reduce confusion, in this subsection we'll refer to the link-layer unit of data exchanged as a packet.) Each time slot is then assigned to one of the N nodes. Whenever a node has a packet to send, it transmits the packet's bits during its assigned time slot in the revolving TDM frame. Typically, slot sizes are chosen so that a single packet can be transmitted during a fixed time slot. Figure 6.9 shows a simple four-node TDM example. Returning to our cocktail party analogy, a TDM-regulated cocktail party would allow one partygoer to speak for a fixed period of time, then allow another partygoer to speak for the same amount of time, and so on. Once everyone had had a chance to talk, the pattern would repeat.&#13;&#10;Description: &#13;&#10;Meet MAC property &#13;&#10;Eliminates collisions and is perfectly fair: Each node gets a dedicated transmission rate of R/N bps during each frame time.&#13;&#10;Good: &#13;&#10;First, a node is limited to an average rate of R/N bps even when it is the only node with packets to send&#13;&#10;A second drawback is that a node must always wait for its turn in the transmission sequence-again, even when it is the only node with a packet to send. Imagine the partygoer who is the only one with anything to say (and imagine that this is the even rarer circumstance where everyone wants to hear what that one person has to say). Clearly, TDM would be a poor choice for a multiple access protocol for this particular party.&#13;&#10;Bad: &#13;&#10;TDMA(Time division multiple access): &#13;&#10;Channel partitioning:&#13;&#10;4/6 Slide 20 cont..: Three categories of MAC address protocol&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD340(1).tmp" width=1070 height=960><BR><IMG 
alt="A second drawback is that a node must always wait for its turn in the transmission sequence-again, even when it is the only node with a packet to send. Imagine the partygoer who is the only one with anything to say (and imagine that this is the even rarer circumstance where everyone wants to hear what that one person has to say). Clearly, TDM would be a poor choice for a multiple access protocol for this particular party.&#13;&#10;It's possible that the utilization rate can be 100%, for example of left side panel:&#13;&#10;If the traffic is not busty, many channel will remain idel, so the utilization can be bad.&#13;&#10;Untitled picture.png 6-slot &#10;6-slot &#10;frame &#13;&#10;TDMA requires the synchronization of clock, so before the transmission, every nodes/sender need to make aggrement on when is the time-slot begin and when ends, to ensure that no collision or big lagging would happen!&#13;&#10;E.g. In a particular case of 6-station LAN, 1,3,4 have packet so send, but slot 2,5, have no packet to send, so they are idle. So, another ananlogy is like, there are 6 device connect to the Home-WiFI network, and only user 1,3,4 are downloading some movie, so they need to use the channel,  but the user 2, 5, 6 just don't have packet to send, so the channel just being idled. &#13;&#10;Example 02:&#13;&#10;FDM divides the R bps channel into different frequencies (each with a bandwidth of R/N) and assigns each frequency to one of the N nodes. FDM thus creates N smaller channels of R/N bps out of the single, larger R bps channel. FDM shares both the advantages and drawbacks of TDM. It avoids collisions and divides the bandwidth fairly among the N nodes. However, FDM also shares a principal disadvantage with TDM-a node is limited to a bandwidth of R/N, even when it is the only node with packets to send.&#13;&#10;Desctiption: &#13;&#10;TDMA ends up wasting slots. TDMA can be modified to skip slots for users that do not have data waiting to be transmitted, but this ends up complicating TDMA considerably. Another simple mechanism to arbitrate access to a shared medium is Frequency Division Multiple Access (FDMA), where each user is given a slice of the frequency range (or bandwidth). Such a slice is also called a channel. &#13;&#10;Motivation: &#13;&#10;each users/nodes own a specific bandwidth, there is no scheduling across time, so the user who owns this frequency band can send data anytime he want! E.g. The bandwidth that used for LTE 4G is about 800MHZ, but the Wifi router for your home device may be like 2.4GHZ. And, different ISP controls different bandwidth of frequency.&#13;&#10;For collision control. e.g. ATT, T-mobile, or Verizon user have different frequency, If all of these different sellers or providers are using the same frequency band. When the signals from these different providers are all going to interfere with each other, so you always want to shift the base band into disjointed band freuqnecy, to make sure no overlapping.&#13;&#10;For modulate between different transmission medias. E.g. Cooper act as a good conductor for specific range of frequency, so any range freuqncy smaller than that, the signal can be seriously attenuated. The size of the antennas that you need to transmit a signal is proportional is going to be proportional to the wavelengths of the signal. So, it you have a very low frequency, then the wavelength of signal can be pretty high, and that means you need a huge antenna, which is not desirable. &#13;&#10;Why do we want to change the bandwidth? Is it for collision control? Why not just sending the signal in base band?&#13;&#10;The Wifi in you home using a small range of frequency, and it share though different user, so it can has more power than satellite. &#13;&#10;divide the channel for different frequency bandwidth, e.g. Wift--2.4 GHz, celluer -- 800 MHz…&#13;&#10;Idea(not on exam, just background information): &#13;&#10;FDMA(Frequency division multiple access): &#13;&#10;" 
src="Lecture%20note_v3_files/mhtD353(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;Untitled picture.png &#13;&#10;The frequency defines the range of signal that a user can send, the actual signal is like that step function, or sinusoidal wave form(at left top plot). And, this is done via Fourier transformation.&#13;&#10;The Wifi in you home using a small range of frequency, and it share though different user, so it can has more power than satellite. &#13;&#10;It avoids collision and divides the bandwidth fairly among the N nodes.&#13;&#10;Good: &#13;&#10;a node is limited to a bandwidth of R/N, even when it's the noly node with packets to send.&#13;&#10;if some channel has no packet to send, such frequency bands idle and get wasted&#13;&#10;Untitled picture.png Example: 6-station LAN. 1, 3, 4 have packets to send, frequency bands &#10;2, 5, 6 idle &#10;FDM cable &#10;time &#13;&#10;Bad: &#13;&#10;How does the collision is being detected?&#13;&#10;How does it being recovered?&#13;&#10;unslotted ALOHA prorotocl is a fully decentralized protocol, and it requires all nodes synchronize tranmission at the beginning of a slot&#13;&#10;In both slotted and pure ALOHA, a node's decision to transmit is made independently of the activity of the other nodes attached to the broadcast channel. In particular, a node neither pays attention to whether another node happens to be transmitting when it begins to transmit, nor stops transmitting if another node begins to interfere with its transmission.&#13;&#10;Description: &#13;&#10;In our cocktail party analogy, ALOHA protocols are quite like a boorish partygoer who continues to chatter away regardless of whether other people are talking. As humans, we have human protocols that allow us not only to behave with more civility, but also to decrease the amount of time spent &quot;colliding&quot; with each other in conversation and, consequently, to increase the amount of data we exchange in our conversations.&#13;&#10;Example: &#13;&#10;ALOHA net (阿罗哈) -- Slotted ALOHA&#13;&#10;Random access protocol&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD375(1).tmp" width=1070 height=960><BR><IMG 
alt="In our cocktail party analogy, ALOHA protocols are quite like a boorish partygoer who continues to chatter away regardless of whether other people are talking. As humans, we have human protocols that allow us not only to behave with more civility, but also to decrease the amount of time spent &quot;colliding&quot; with each other in conversation and, consequently, to increase the amount of data we exchange in our conversations.&#13;&#10;All frames consist of exactly L bits.&#13;&#10;Time is divided into slots of size L/R seconds (that is, a slot equals the time to transmit one frame).&#13;&#10;Nodes start to transmit frames only at the beginnings of slots.&#13;&#10;The nodes are synchronized so that each node knows when the slots begin.&#13;&#10;If two or more frames collide in a slot, then all the nodes detect the collision event before the slot ends.&#13;&#10;Assumption:&#13;&#10;If node has a fresh frame, trainsmit entire frame in next slot. &#13;&#10;If no collision, a frame is trainsmitted succssfully, and the node can prepare a new frame for transmission!&#13;&#10;It's like each user will &quot;flip a coin&quot; independently, and use it to decide whether to send the packet at next time slot&#13;&#10;In this case, we have a collisio at slot 4, so the entire frame is wasted, but the probability of having a sequence of collision will be very small.&#13;&#10;Frame == channel? ==> Frame is the link-layer unit of data exchanged between sender and receiver, which defines the length of data we can send. Channel is the pipeline? &#13;&#10;Untitled picture.png &#13;&#10;Could we do a first come first server? I mean when there is a colision happen. ==> The time is synchronized. Everybody start at the same moment!&#13;&#10;If there is a collision, retransmit the frame with probability p in each subsequent slot until success. &#13;&#10;Operation: &#13;&#10;Single active nodes(A node is said to be active if it has frames to send) can continuously transmit at full rate of channel.&#13;&#10;It's Decenralized: because each node detects collisions and independently decides when to retransmit. (Slotted ALOHA does however, require the slots to be synchronized in the nodes;)&#13;&#10;Simple to implement&#13;&#10;Good/Pros:&#13;&#10;Untitled picture.png node 1 &#10;node 2 &#10;node 3 &#10;1 &#10;2 &#10;Collision &#10;ille &#10;1 &#10;2 &#10;aollision Success &#13;&#10;Collision wasted slot: The fist and third slot is being wasted because of collision happen! (If time parameter is too small, you might has a lot of idles slot). &#13;&#10;Collision waste the time-slots: Slotted ALOHA works well when there is only one active node, but the efficiency is bad when there are mulitple active nodes. Two possible efficiency concerns here:&#13;&#10;Bad/Cons/Drawback:&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD388(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png node 1 &#10;node 2 &#10;node 3 &#10;1 &#10;2 &#10;Collision &#10;ille &#10;1 &#10;2 &#10;aollision Success &#13;&#10;Idel slot: The second slot is empty because of the probabilistic transmission policy. &#13;&#10;Instead of stop transmitting the packet while collision detected, it still choose to send the packet, but nodes may be able to detection collision in less than time to transmit packet&#13;&#10;Requires Clock synchronization&#13;&#10;Untitled picture.png (O &quot; 402 &#13;&#10;Can be use to define average utilization of link: In this case, only 20% of change the transmission will be success&#13;&#10;Probability that a given nodes transmits is p; the probability that the remaining nodes don't transmit is (1-p)^N-1 ==> the probability that a given nodes has a successful slot is p * (1-p)^N-1. ==> Because there are N nodes, the probability that any one of the N nodes has a successful slot is = N * p * (1-p)^N-1,  &#13;&#10;At best: we can have 37% transmission utilization. Thus the maximum efficiency transmission rate of a channel is not R bps but 37% R bps!&#13;&#10;ALOHA efficientcy&#13;&#10;Listen before speaking. If someone else is speaking, wait until they are finished. In the networking world, this is called carrier sensing-a node listens to the channel before transmitting. If a frame from another node is currently being transmitted into the channel, a node then waits until it detects no transmissions for a short amount of time and then begins transmission.&#13;&#10;If someone else begins talking at the same time, stop talking. In the networking world, this is called collision detection- a transmitting node listens to the channel while it is transmitting. If it detects that another node is transmitting an interfering frame, it stops transmitting and waits a random amount of time before repeating the sense-and-transmit-when-idle cycle. &#13;&#10;Two important rules for polite conversation:&#13;&#10;After all, a node will refrain from transmitting whenever it senses that another node is transmitting. The answer to the question can best be illustrated using space-time diagrams:&#13;&#10;Untitled picture.png Time &#10;Time &#10;Figure 6.12 • Space-time diagram of N'•/O CSMA nodes with colliding &#10;transmissions &#13;&#10;At time t0, node B senses the channel is idle, as no other nodes are currently transmitting. Node B thus begins transmitting at t0, with its bits propagating in both directions along the broadcast medium. The downward propagation of B's bits in Figure 6.12 with increasing time indicates that a nonzero amount of time is needed for B's bits actually to propagate (albeit at near the speed of light) along the broadcast medium. At time t1 (t1 > t0), node D has a frame to send. Although node B is currently transmitting at time t1, the bits being transmitted by B have not reach to D, and thus D senses the channel idle at t1. In accordance with the CSMA protocol, D thus begins transmitting its frame. A short time later, B's transmission begins to interfere with D's transmission at D. From Figure 6.12, it is evident that the end-to-end channel propagation delay of a broadcast channel -- the time it takes for a signal to propagate from one of the nodes to another -- will play a crucial role in determining its performance. The longer this propagation delay, the larger the chance that a carrier-sensing node is not yet able to sense a transmission that has already begun at another node in the network.&#13;&#10;Q: do collisions occur in the first place?&#13;&#10;CSMA(Carrier sense multiple access) &#13;&#10;" 
src="Lecture%20note_v3_files/mhtD3AA(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Time &#10;Time &#10;Figure 6.12 • Space-time diagram of N'•/O CSMA nodes with colliding &#10;transmissions &#13;&#10;CSMA do not perform collision detection; both B and D continue to transmit their frames in their entirety even though a collision has occurred. When a node performs collision detection, it ceases transmission as soon as it detects a collision. Clearly, adding collision detection to a multiple access protocol will help protocol performance by not transmitting a useless, damaged (by interference with a frame from another node) frame in its entirety.&#13;&#10;Untitled picture.png Space &#10;Collision &#10;d bort &#10;time &#10;Time &#10;Figure 6.13 • CSMA with collision detection &#13;&#10;Motivation:&#13;&#10;CSMA/CD (Carrier Sense Multiple Access with Collision Dection) -- Used in Ethernet&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD3CC(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png Space &#10;Collision &#10;d bort &#10;time &#10;Time &#10;Figure 6.13 • CSMA with collision detection &#13;&#10;After receivied a datagram from network layer, prepare link-layer frame and put into the buffer&#13;&#10;If channel is busy, then wait until it sense no signal being transmitted and then trasmits the packet/frame.&#13;&#10;While transmitting, keep monitoring the signal energy in the broadcast channel.&#13;&#10;if no collision detected, the frame transmitted successfully; otherwise abort transmission and send/broadcast jam signal. &#13;&#10;After m-th collision, NIC chooses K at random from {0, 1, …, 2m-1} and waits K*512 bit times and returns to step 2  (e.g., 5.12 microseconds for a 100 Mbps Ethernet). &#13;&#10;After aborting,  enters binary exponential backoff (wait a random amount of time) and return to step 2:&#13;&#10;CSMA/CD Algorithm/Operation:&#13;&#10;if two nodes transmitted frames at the same time and then both waited the same fixed amount of time, they 'd continue colliding forever. What we'd like is an interval that is short when the number of colliding nodes is small, and longer when the number of colliding nodes is large.  This problem is solved elegantly with Binary exponential backoff algoirthm. &#13;&#10;Specifically, when transmitting a frame that has already experienced n collisions, a node chooses the value of Kat random from {0,1 ,2, .... 2&quot;-1 }. Thus, the more collisions experienced by a frame, the larger the interval from which K is chosen. For Ethernet, the actual amount of time a node waits is K · 512 bit times (i.e., K times the amount of time needed to send 512 bits into the Ethernet) and the maximum value that n can take is capped at I 0.&#13;&#10;For example:  If the node chooses K = 0, then it immediately begins sensing the channel. If the node chooses K = I , it waits 512 bit times (e.g., 5.12 microseconds for a 100 Mbps Ethernet) before beginning the sense-and-transmit-when-idle cycle. After a second collision, K is chosen with equal probability from {0,1,2,3}. After three collisions, K is chosen with equal probability from {0,1,2,3,4,5,6,7}. After 10 or more collisions, K is chosen with equal probability from {0,1 ,2, ... , 1023}. Thus, the size of the sets from which K is chosen grows exponentially with the number of collisions; for this reason this algorithm is referred to as binary exponential backoff.&#13;&#10;Binary exponential backoff algoirthm(二进制指数后退算法). &#13;&#10;Yes, the propagation delay still exist, it's possible when one send the packet, but other's not listen and is in the middlle of packet transmission.. Because of propagation delay, the packet take time to transmit. As a result the entire packet transmission time might get wasted!&#13;&#10;Untitled picture.png spatial layout of nodes &#13;&#10;In this example, at t1, nodes 4 sense no packet being transmitted,  so he start to send the packets. However, in fact, nodes 2 had transmitted a nodes at t0, but it takes some time to have nodes 4 get notified until t3, so a collision happened here, and whole frame from both nodes get dropped/wasted!&#13;&#10;So CSMA can minimize the collision but not eliminate it. The longer this propagation delay, the larger the chance that a carrier-sensing node is not yet able to sense a transmission that has already begun at another node in the network. Therefore, shorter the propagation delay, better the utilization for CSMA: &#13;&#10;Could the collision still happen?&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD3EF(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png spatial layout of nodes &#13;&#10;Collision can be detected within short time, so if the collision detected (By using the magnitude of overlapping signal), we will choose the stop transmit the packet!&#13;&#10;When only one node has a frame to send, the node can transmit at the full channel rate (e.g. , for Ethernet typical rates are lO Mbps, 100 Mbps, or 1 Gbps).&#13;&#10;Pros:&#13;&#10;It listen before transmition. If it sense the channel is being idle, start transmit the entire frame; Otherwise we defer transmission until sense no signal energy and then transmit. (A nodes cannot read the information at channel, but we can detect whether the channel is being used or not.)&#13;&#10;What is carreier sensing? &#13;&#10;After a collision detected; ALOHA throws the randomness in choosing whether to send a frame or not, and CSMA/CD use a randomized interval in deciding the waiting time to try again! (Something associate with Binary exponenetial backoff) &#13;&#10;the probability p is fixed in ALOHA, but the randomized waiting time in CSMA/CD is chosen dynamically, like previous window size.&#13;&#10;ALOHA Vs CSMA with Detection&#13;&#10;Recall that two desirable properties of a multiple access protocol are (I) when only one node is active, the active node has a throughput of R bps, and (2) when M nodes are active, then each active node has a throughput of nearly R/M bps. The ALOHA and CSMA protocols have this first property but not the second.&#13;&#10;Motivation:&#13;&#10;The polling protocol requires one of the nodes (can be anyone) to be designated as a master node. The master node polls each of the nodes in a round-robin fashion. In particular, the master node first sends a message to node 1, saying that it (node 1) can transmit up to some maximum number of frames. After node 1 transmits some frames, the master node tells node 2 it (node 2) can transmit up to the maximum number of frames. (The master node can determine when a node has finished sending its frames by observing the lack of a signal on the channel.) The procedure continues in this manner, with the master node polling each of the nodes in a cyclic manner. One real world application is Bluetooth. &#13;&#10;Description:&#13;&#10;Polling protocol&#13;&#10;Two important Taking-Turn protocols:&#13;&#10;Taking-Turn protocols&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD411(1).tmp" width=1070 height=960><BR><IMG 
alt="The polling protocol requires one of the nodes (can be anyone) to be designated as a master node. The master node polls each of the nodes in a round-robin fashion. In particular, the master node first sends a message to node 1, saying that it (node 1) can transmit up to some maximum number of frames. After node 1 transmits some frames, the master node tells node 2 it (node 2) can transmit up to the maximum number of frames. (The master node can determine when a node has finished sending its frames by observing the lack of a signal on the channel.) The procedure continues in this manner, with the master node polling each of the nodes in a cyclic manner. One real world application is Bluetooth. &#13;&#10;If a nodes has a data to send, master node will poll the frame from nodes and start the transmission.&#13;&#10;Untitled picture.png master &#10;Non-master &#13;&#10;If a nodes had no data to send, master node will skip it and move to next nodes. &#13;&#10;Eliminates the collisions and empty slots that plague random access protocols.&#13;&#10;Achieve a much higher efficiency than random access protocols&#13;&#10;Meet the second property of MAC protocol&#13;&#10;Advantage:&#13;&#10;The first drawback is that the protocol introduces a polling delay/overhead -- the amount of time/resources required to notify a node that it can transmit. If, for example, only one node is active, then the node will transmit at a rate Jess than R bps, as the master node must poll each of the inactive-nodes in turn each time the active node has sent its maximum number of frames.&#13;&#10;The second drawback is potentially more serious. If the master node fails, the entire channel becomes inoperative.&#13;&#10;Drawback:&#13;&#10;Untitled picture.png (nothing &#10;to send) &#10;data &#13;&#10;In this protocol there is no master node. A small, special-purpose frame known as a token is exchanged among the nodes in some fixed order.&#13;&#10;Description:&#13;&#10;For example, node l might always send the token to node 2, node 2 might always send the token to node 3, and node N might always send the token to node l. When a node receives a token, it holds onto the token only if it has some frames to transmit; otherwise, it immediately forwards the token to the next node. If a node does have frames to transmit when it receives the token, it sends up to a maximum number of frames and then forwards the token to the next node.&#13;&#10;Example:&#13;&#10;Token-passing protocol&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD433(1).tmp" width=1070 height=960><BR><IMG 
alt="For example, node l might always send the token to node 2, node 2 might always send the token to node 3, and node N might always send the token to node l. When a node receives a token, it holds onto the token only if it has some frames to transmit; otherwise, it immediately forwards the token to the next node. If a node does have frames to transmit when it receives the token, it sends up to a maximum number of frames and then forwards the token to the next node.&#13;&#10;Decentralized and highly efficient.&#13;&#10;Barely Meet the first and second property of MAC protocol&#13;&#10;Advantage:&#13;&#10;The failure of one node can crash the entire channel.&#13;&#10;If a node accidentally neglects to release the token, then some recovery procedure must be invoked to get the token back in circulation.&#13;&#10;Token delay/overhead -- The time/resources required to pass over the token.&#13;&#10;Drawback:&#13;&#10;Note: Collision detection in wireless is difficult, because the power of signal is weak, so we do collision avoidance in wireless(e.g. WIFi), it's more like proactive scheme. So, after you transmit a packet, you waiting a random amount of time before transmitting next packet.&#13;&#10;Error can be caused by signal attenuation, noise, or interference&#13;&#10;Error detection: detect whether bits have dlipped within packet&#13;&#10;Error correction: automatically correctly flip the bits without requiring retransmission, e.g. LDPC)low-density parity check code&#13;&#10;Note: the research at error detection/correction had been study over 70-80, so the currection application is really the state-of-art, very mathmatically determination.&#13;&#10;Description:&#13;&#10;Idea: append &quot;redundant&quot; bits to frame, for detection purpose. Generally, those techniques are not 100% reliable, but greater the redundancy greater the reliability.&#13;&#10;EDC (Error detection and correction)&#13;&#10;If x%2 != 0 ==> parity bit = 1; &#13;&#10;Otherwise, parity bit = 0;&#13;&#10;x =  the number of 1 in data bits&#13;&#10;Untitled picture.png 4— data bits &#10;0111000110101011 1 &#10;parity bit &#13;&#10;Example:&#13;&#10;Single bit parity:&#13;&#10;Introduction: A multidimensional parity-check code (MDPC) is a simple type of error correcting code that operates by arranging the message into a multidimensional grid, and calculating a parity digit for each row and column. The two-dimensional parity-check code, usually called the optimal rectangular code, is the most popular form of MDPC. &#13;&#10;Untitled picture.png dlJ &#10;d &#10;2,] &#10;d &#10;parity &#10;d &#10;d &#10;i,j+l &#10;column &#10;parity &#10;101011 &#10;01110 &#10;101010 &#10;no errors &#10;1 &#10;o &#10;1 &#10;...l,j di+l &#10;1011 &#10;parity &#10;error &#10;1101 &#10;1010 &#10;pa rity &#10;error &#10;correctable &#10;single bit error &#13;&#10;Example:&#13;&#10;Two-dimensional parity-check code: &#13;&#10;Error detecion and correction&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD446(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png dlJ &#10;d &#10;2,] &#10;d &#10;parity &#10;d &#10;d &#10;i,j+l &#10;column &#10;parity &#10;101011 &#10;01110 &#10;101010 &#10;no errors &#10;1 &#10;o &#10;1 &#10;...l,j di+l &#10;1011 &#10;parity &#10;error &#10;1101 &#10;1010 &#10;pa rity &#10;error &#10;correctable &#10;single bit error &#13;&#10;Untitled picture.png ~ D ID &#10;llO ㄇ 0 &#10;/ ~ O I D / 0 0 &#10;blo &#13;&#10;Can detect and correct single-bit error, but, for double-bit or multiple-bit error, only able to detect the error.&#13;&#10;Drawback:&#13;&#10;D: data bits, as a binary number&#13;&#10;r: is chosen arbitrary, defines the number of bit in G. The larger the r the more reliable the transmission&#13;&#10;G: generator code, generated by random generator, size(G) = r +1&#13;&#10;<D, R> is exactly divisible by G (modulo 2)&#13;&#10;Receiver knows G, divides <D, R> by G, if non-zero remainder, then error detected!&#13;&#10;Untitled picture.png 0 「 フ / ゆ ロ り 。 ク 「 0 凵 0 冫 死 一 &#10;/ り ク 0 / 0 「 ) ー ー 0 : ツ 巳 毛 ク し / こ &#13;&#10;burst error means the a long sequence of error bit.&#13;&#10;Can detect all burst error less than r+1 bits&#13;&#10;Goal: choose r CRC bits, such that&#13;&#10;Note: When you doing this long division, since the &quot;modulo 2&quot; mechanism, instead of doing the regumar mathmetic subtraction, we do the &quot;modulo 2 version subtraction&quot;, which is XOR operation. Example of fifth line, 1010 - 1001 =0011, so we are actually doing the XOR operation. &#13;&#10;Example of long division:&#13;&#10;CRC (Cyclic Redundancy Check)&#13;&#10;One interesting property of MAC addresses is that no two adapters have the same address. How does a company manufacturing adapters in Taiwan make sure that it is using different addresses from a company manufacturing adapters in Belgium? The answer is that the IEEE manages the MAC address space. In particular, when a company wants to manufacture adapters, it purchases a chunk of the address space consisting of 2^24 addresses for a nominal fee. An adapter's MAC address is analogous to a person's social security number, and an IP address is analogous to a person's postal address. As a person moves, his postol adddr will changes but his security number remain fixed permanently. Just as a person may find it useful to have both a postal address and a social security number, it is useful for a host and router interfaces to have both a network-layer address and a MAC address.&#13;&#10;Description:&#13;&#10;MAC Addresses&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD468(1).tmp" width=1070 height=960><BR><IMG 
alt="One interesting property of MAC addresses is that no two adapters have the same address. How does a company manufacturing adapters in Taiwan make sure that it is using different addresses from a company manufacturing adapters in Belgium? The answer is that the IEEE manages the MAC address space. In particular, when a company wants to manufacture adapters, it purchases a chunk of the address space consisting of 2^24 addresses for a nominal fee. An adapter's MAC address is analogous to a person's social security number, and an IP address is analogous to a person's postal address. As a person moves, his postol adddr will changes but his security number remain fixed permanently. Just as a person may find it useful to have both a postal address and a social security number, it is useful for a host and router interfaces to have both a network-layer address and a MAC address.&#13;&#10;Everytime we want to pass througth this &quot;Giant blue cloud&quot;,network switch, the link-layer will resolve the MAC address and IP address, and decide the the next hop to go.&#13;&#10;Untitled picture.png MAC src: 74-29-9C-E8-FF-55 &#10;MAC dest: E6-E9-OO-17-BB-4B &#10;IP src: 111.111.111.111 &#10;IP dest: 222.222.222.222 &#10;Eth &#10;Phy &#10;111.111.111.111 &#10;74-29-9C-E8-FF-55 &#10;111.111.111.112 &#10;CC-49-DE-DO-AB-7D &#10;Eth &#10;Phy &#10;222.222.222.220 &#10;IA-23-F9-CD-06-9B &#10;111.111.111.110 &#10;E6-E9-OO-17-BB-4B &#10;222.222.222.222 &#10;49-BD-D2-C7-56-2A &#10;222. 22.222.221 &#10;88-B2-2F-54-1A-OF &#13;&#10;Untitled picture.png 11 一 .111 一 111 , 111 &#10;A &#10;111 」 一 1 - 111 」 一 2 &#10;2222222 222 &#10;: 一 」 11 1 二 - 1 &#10;222 一 222 2 - 0 &#10;222 2 222-221 &#10;49 甶 0 • 02 • G7 24 &#10;B &#13;&#10;E.g. If node A want to send a message to node B, node A will be the starting point, and router R will be the next hop, and node B will be the final stop. In link-layer, node A will encapsulate the Link-layer frame with src/dest MAC addrress, when the packet reached the router R, it will decapsulate the frame, and we are in routing-layer. Router will use the src/dest IP addr to determine where is the next hop the packet should be send to. In the sender interface, router R will also encapsulate a new src/desc MAC address(but src/dest IP addr don't changes), and so on and so forth, until the packet reached destination.&#13;&#10;In MAC addr routing, only the end deviced has MAC address but switch don't, and the switch don't have the concept of &quot;forwarding table&quot;. So how does switch know where the frame should be send to? With the help of ARP(Address resolution protocol)&#13;&#10;What is differnet bettween the IP addr routing and MAC addr routing? &#13;&#10;Implementation:&#13;&#10;Ethernet has pretty much taken over the wired LAN market. Today, Ethernet is by far the most prevalent wired LAN technology, and it is likely to remain so for the foreseeable future. &#13;&#10;There are many reasons for Ethernet's success. First, Ethernet was the first widely deployed high-speed LAN. Because it was deployed early, network administrators became intimately familiar with Ethernet-its wonders and its quirks-and were reluctant to switch over to other LAN technologies when they came on the scene. Second, token ring, FDDI, and ATM were more complex and expensive than Ethernet, which further discouraged network administrators from switching over. Third, the most compelling reason to switch to another LAN technology (such as FDDI or ATM) was usually the higher data rate of the new technology; however, Ethernet always fought back, producing versions that operated at equal data rates or higher. Switched Ethernet was also introduced in the early 1990s, which further increased its effective data rates. Finally, because Ethernet has been so popular, Ethernet hardware (in particular, adapters and switches) has become a commodity and is remarkably cheap.&#13;&#10;Motivation: implement based on switch based, so multiple user sharing is not today's network problem. &#13;&#10;Ethernet&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD48A(1).tmp" width=1070 height=960><BR><IMG 
alt="There are many reasons for Ethernet's success. First, Ethernet was the first widely deployed high-speed LAN. Because it was deployed early, network administrators became intimately familiar with Ethernet-its wonders and its quirks-and were reluctant to switch over to other LAN technologies when they came on the scene. Second, token ring, FDDI, and ATM were more complex and expensive than Ethernet, which further discouraged network administrators from switching over. Third, the most compelling reason to switch to another LAN technology (such as FDDI or ATM) was usually the higher data rate of the new technology; however, Ethernet always fought back, producing versions that operated at equal data rates or higher. Switched Ethernet was also introduced in the early 1990s, which further increased its effective data rates. Finally, because Ethernet has been so popular, Ethernet hardware (in particular, adapters and switches) has become a commodity and is remarkably cheap.&#13;&#10;Total 8 byte for preamble, the first 7 bytes with pattern 10101010 followed by one byte with pattern 10101011 (The last one byte is for syncrhonization)&#13;&#10;The Ethernet frame begins with an 8-byte preamble field. Each of the first 7 bytes of the preamble has a value of 10101010; the last byte is 10101011. The first 7 bytes of the preamble serve to &quot;wake up&quot; the receiving adapters and to synchronize their clocks to that of the sender's clock. &#13;&#10;Used to synchronize receiver, sender clock rates &#13;&#10;Because the adapter at receiver side and sender side has different frequencies, so the frame might not be transmitted at exactly the target rate, so we need to synchonrize their clock.&#13;&#10;&#13;&#10;Why do we need the synchronization?&#13;&#10;Preamble: &#13;&#10;Untitled picture.png preamble &#10;address &#10;Source &#10;address &#13;&#10;Ethernet frame structure&#13;&#10;Store, forward Ethernet frames&#13;&#10;Examines incoming frame's MAC address, and forward frame to appropriate outgoing link&#13;&#10;Can buffer packets&#13;&#10;Link-layer device&#13;&#10;Each switch has a switch table for forwarding packets&#13;&#10;Each entry of table ha&#13;&#10;Forwarding table&#13;&#10;Motivation: switch is actually what is being used in today modern network.&#13;&#10;Ethernet switch (similar to the mechanism of router)&#13;&#10;Used to exchange data only within a Local area network, not outside the network(Outide the network need to be able to read IP address). &#13;&#10;Untitled picture.png Switch &#10;SWITCH TABLE &#10;DATA DIRECTED ONLY TO &#10;INTENDED PORT &#10;o &#10;PORT &#10;2 &#10;3 &#10;4 &#10;DEVICE &#10;DETECTED &#10;DETECTED &#10;DETECTED &#10;DETECTED &#10;MAC ADDRESS &#10;0004.SAG3-Al-66 &#10;90-02-7B-C2.CO.67 &#10;3207-9A-92-A200 &#10;72-00-FA-63-A9-66 &#13;&#10;Untitled picture.png &#13;&#10;Can Detect specific device that connected to it, and exchange Data directed only to intended port.&#13;&#10;Switch: &#13;&#10;Switch Vs Routers (Trade of between simplicity and performance)&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD49D(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;Untitled picture.png Router &#10;The &#10;960 network &#10;Data rejected by rout r. &#10;Sent off to another network. &#13;&#10;Router are used to connect network, and allow to exchange data for different local area network.&#13;&#10;Router: &#13;&#10;Both are store-and-forward. However, the routers forwards the datagram's destination IP address, and the switch forwards the frame's destination MAC address.&#13;&#10;Both have forwarding tables&#13;&#10;Similarity:&#13;&#10;Routes: have complicated routing algorithm to compute the forwarding table.&#13;&#10;Untitled picture.png a plication &#10;ansport &#10;etwork &#10;data ram &#10;frame &#10;amine &#10;link &#10;hysical &#10;switch &#10;pplication &#10;transport &#10;network &#10;link &#10;ne &#10;frame &#10;hysical &#10;da ram &#10;nk &#10;frame &#10;ph sical &#13;&#10;Switches: no forwarding table, it's more like a plug-and-play devices (No need to configure). They learn the forwarding table automatically via flooding(which means broadcasting the MAC address to all devices), but what they learn are not necessary the optimal path. E.g. when a packet arrives switch, if the forwarding table is empty, or the packet Dest MAC address doesn't match any entry on the switch forwarding table. Then the Ethernet switch is gonna send the link-packet to all neightboor nodes' interface (except the one which it arrives).&#13;&#10;Difference&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD4BF(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png a plication &#10;ansport &#10;etwork &#10;data ram &#10;frame &#10;amine &#10;link &#10;hysical &#10;switch &#10;pplication &#10;transport &#10;network &#10;link &#10;ne &#10;frame &#10;hysical &#10;da ram &#10;nk &#10;frame &#10;ph sical &#13;&#10;&#13;&#10;Untitled picture.png &#13;&#10;It transform these bits from the link layer into analog signal(e.g. Voltage, EM wave) at sender side, when it arrived receiver you transform back to bit again. But the actual implementation at physical layer can varies depending on the transmission medium.&#13;&#10;What is the functionality of pyhsical layer:&#13;&#10;Untitled picture.png &#13;&#10;What is modulation: It's the process of converting the sequence of bit that the link layer wants to send to the continuous analog signal that physical layer wants.&#13;&#10;Untitled picture.png D / 1 p &#10;2 &#13;&#10;What is an neat way to transform the digital bit to analogy signal?&#13;&#10;Modulation: �HYPERLINK &quot;https://www.youtube.com/watch?v=Iyzpt3bKTTI&amp;list=PLuUdFsbOK_8pWzW7KJjbiJ8Ow0cdHlApV&amp;index=8&quot;Understanding Modulation! | ICT  #7&#13;&#10;4/22 Slide 22: Pyhscial layer:&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD4E1(1).tmp" width=1070 height=960><BR><IMG 
alt='Untitled picture.png D / 1 p &#10;2 &#13;&#10;Untitled picture.png &#13;&#10;==> have other variance between -v to +v so that we can represents multiple bits, known as PAM(Pulse Amplitude Modulation)&#13;&#10;Q: is there other way to represent them?&#13;&#10;carrier signal: list adaptoer, amplify the signals between wires/hubs&#13;&#10;Untitled picture.png &#13;&#10;Take a sequence of bit convert to impulse symbol, and convert sequence of symbol to baseband signal(which is more continuous signal), and then convert baseband signal to passband signal (which mean shiting to a higher frequence band via carrier wave)&#13;&#10;Process of modulation:, �HYPERLINK "https://www.youtube.com/watch?v=Iyzpt3bKTTI&amp;list=PLuUdFsbOK_8pWzW7KJjbiJ8Ow0cdHlApV&amp;index=8"https://www.youtube.com/watch?v=Iyzpt3bKTTI&amp;list=PLuUdFsbOK_8pWzW7KJjbiJ8Ow0cdHlApV&amp;index=8&#13;&#10;' 
src="Lecture%20note_v3_files/mhtD504(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;Untitled picture.png &#13;&#10;You can send two sequence of sinusoidal symbol, one sine and one cosine, and they can be transmitted simultaneously.&#13;&#10;bacause the baseband signal has wider range wave, and different media might use different bandwith (e.g antennat using 800MHz, and WiFi use 2.4 GHz), so we could shiting the baseband to a narrower range, and to reduce the interference.&#13;&#10;Untitled picture.png &#13;&#10;Because the interference is very noisy if we have multiple users&#13;&#10;What is the purpose to change the band?&#13;&#10;How does the carrier wave conver the baseband signal to passband signal?&#13;&#10;Because noise. What user receive is not exactly the symbol of what has sends&#13;&#10;Untitled picture.png &#13;&#10;And, when we have multiple user, if the noise region is wide, we might have a lot of noise will be overlapped, and we cannot tells two symble apart anymore!&#13;&#10;Why couldn't we spread/space out the distance between two transmission point so they don't overlap?&#13;&#10;Why do we converts those bit to two dimension? Instead of higher dimension, like 3, 4…&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD526(1).tmp" width=1070 height=960><BR><IMG 
alt="Untitled picture.png &#13;&#10;Because of power constrain. The amount of energy/power reqruied to transmit the signal is proportion of the square of amplitude. &#13;&#10;Why couldn't we spread/space out the distance between two transmission point so they don't overlap?&#13;&#10;Untitled picture.png (-CVE) &#10;C) &#10;(-C-VE) &#10;Can fit &#10;Rate = &#10;nois &#10;2 &#10;nois &#10;Is per row, column &#10;s per transmission &#10;bits per transmission &#10;= log2 &#10;noise &#10;Signal-to-noise ratio (SNR) &#13;&#10;We cannot compact those point too close to each other because of te level of robustness wo against noise will decrease, and we also know that we cannot spread out those point too far away from origin because of power limitation. So this lead to the question what is really the best way to organize those points? ==> (2*the length of rectangular / 2*radius of noise region)&#13;&#10;&#13;&#10;Untitled picture.png 8-PSK &#10;(Phase &#10;Shift &#10;011 &#10;001 &#10;000 &#10;010 &#10;100 &#10;110 &#10;111 &#10;101 &#10;16-QAM &#10;(Quadrature &#10;Amplitude &#10;Modulation) &#10;0000 &#10;0001 &#10;0011 &#10;0010 &#10;0100 &#10;0111 &#10;0111 &#10;0110 &#10;1100 &#10;1101 &#10;1110 &#10;1000 &#10;1001 &#10;1011 &#10;1010 &#13;&#10;E.g.  8-PSK is log_2(8) == 3, log_2(16) == 4&#13;&#10;Q: why the number of bit you can send is log2…?&#13;&#10;Most of this discussion carries over to the wireless physical layer as well. The difference between the wired and wireless physical layer have to do with attenuation, multipath, and interference in a wireless medium. Attenuation refers to how the voltage level of the transmitted bits degrades as we get further and further from the transmitter (this is just a consequence of the EM wave being an electric field). Multipath refers to how the EM waves from the transmitter to the receiver can take different paths. The waves arriving at the receiver from different paths can constructively or destructively interfere at the receiver depending on small differences in the receiver’s position. One simplified view of both attentuation and multipath is that it reduces the SNR at the receiver in a wireless link. Interference refers to how EM waves from multiple transmitters can arrive at the receiver at the same time, destroying the reception of the signal for all transmitters in the process.&#13;&#10;Difference between wired and wireless:&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD538(1).tmp" width=1070 height=960><BR><IMG 
alt="Most of this discussion carries over to the wireless physical layer as well. The difference between the wired and wireless physical layer have to do with attenuation, multipath, and interference in a wireless medium. Attenuation refers to how the voltage level of the transmitted bits degrades as we get further and further from the transmitter (this is just a consequence of the EM wave being an electric field). Multipath refers to how the EM waves from the transmitter to the receiver can take different paths. The waves arriving at the receiver from different paths can constructively or destructively interfere at the receiver depending on small differences in the receiver’s position. One simplified view of both attentuation and multipath is that it reduces the SNR at the receiver in a wireless link. Interference refers to how EM waves from multiple transmitters can arrive at the receiver at the same time, destroying the reception of the signal for all transmitters in the process.&#13;&#10;These 3 problems typically don’t show up on a wired link, which is why wired links have higher SNRs (and hence higher capacity) than wireless links.&#13;&#10;Capacity: the maximum rate at which bits can reliably be transmitted across the channel&#13;&#10;Untitled picture.png + SNR) &#13;&#10;Capcity of Gaussian noise: the maixmum number of bit you can send per symbol/transmission&#13;&#10;How many symbol we can send per second?&#13;&#10;Different channel can accept/limit to certain range of frequency/bandwidth (e.g. 300 mHz for antenna, 2.4Ghz for Wifi)&#13;&#10;Why is bandwidth important to us?&#13;&#10;Capacity of channel&#13;&#10;if you want to produce a bandwidth B hertz, you can send a symbol of gap 1/2B per second, you can construct a continuous sinusoid signal.&#13;&#10;It's allowed to increase the gap but not decrease, because the frequence will be greater than B hertz. &#13;&#10;Because FCC define the range of frequence/bandwidth you can send, so you want to use it as much as you can, and Nyquist theorem could tell you what is the best Symbol transmission rate (number of symbol per second) you should use.&#13;&#10;Nyquist theorem:&#13;&#10;capacity of link: throughput&#13;&#10;throughtput is the property for a user&#13;&#10;and the capacity of link is for the channel&#13;&#10;Capacity of channel&#13;&#10;&#13;&#10;Summary:&#13;&#10;1) The reason to have Nyquist theorem is because FCC defines the range of frequency/bandwidth you can send, so you want to use it as much as you can (because of that cost money), and by using Nyquist theorem, it could tell us what is the best Symbol transmission rate (number of symbol per second) you should use, right?&#13;&#10;2) I kinda confused with the logic of several words in the slide: the capacity of the channel, number of bit per symbol, number of symbol per second. I wonder how do they being measured? and what are the relationship between them?&#13;&#10;&#13;&#10;The&nbsp;capacity of the channel is measured by the maximum number of bit you send over a link per second, which is defined by this formula:&#13;&#10;Untitled picture -log2(1 + SNR) = Blogz(l + SNR) &#10;bits/second &#10;bits/second &#10;E: power per symbol &#10;62: noise power &#13;&#10;where, B is the bandwith in Hertz, E is the signal power in Watt(which varies as the square of the voltage), sigma^2 is the noise power. The overall unit is the capacity &nbsp;of the channel in bits/sec.&#13;&#10;&#13;&#10;and the number of bit per symbol is defined by this formula:&#13;&#10;Untitled picture bits per transmission &#10;= log2 &#10;noise &#10;Signal-to-noise ratio (SNR) &#13;&#10;and the number of bit per symbol is defined by this formula (Which supported by Nyquist theorem? Or Shannon theory?):&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD55B(1).tmp" width=1070 height=960><BR><IMG 
alt="and the number of bit per symbol is defined by this formula (Which supported by Nyquist theorem? Or Shannon theory?):&#13;&#10;Untitled picture 1 &#10;+ SNR) bits per transmission &#10;2 &#13;&#10;&#13;&#10;From <https://outlook.office.com/mail/inbox/id/AAQkADY1YzdkZjI2LWU1MjQtNDRiZC05YTJhLTVlODA4YTgwYmViZgAQADOZfpy3ghVAiVvDf8yyuO0%3D> &#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;Untitled picture.png Workstation &#10;Workstation &#10;HUB &#10;Workstation &#10;Workstation &#13;&#10;Switch: aka switching hub. It's similar to a hub, but it allows multiple device to communicate. &#13;&#10;Hub: a physical layer device that allows for connections from many computers at once. It can possibly cause a large collision domain(A network segment where only one device can communicate at a time), and seriously slow down the network communicaiton, and that''s the reson hubs are fairly rare.&#13;&#10;Definition:&#13;&#10;This is to provide a certain level of robustness to noise, which can modify the voltage while it is being transmitted from the sender to the receiver end of a wire.&#13;&#10;Noise is an unavoidable reality of any analog system, and is the key difference between the analog and digital worlds. Noise occurs for many reasons, e.g., manufacturing defects in the cables and the transmitter/receiver, imperfect contact between the transmitter and the cable, etc. Noise is what you are hearing when you hear static on your radio.&#13;&#10;Why does each value (or bit pattern) correspond to a range of voltages as opposed to a specific voltage?&#13;&#10;Translating bits into voltages&#13;&#10;&#13;&#10;Extra note:&#13;&#10;Connects difference devices to each other, allowing data to be transmitted over them. &#13;&#10;Crosstalk: when a electrical pulse on one wire is accidentally detected on aother wire.&#13;&#10;Copper cable: e.g. Cat5(categoies 5 cable), Cat5e, and Cat6&#13;&#10;Cables:&#13;&#10;The Basics of Networking Devices:&#13;&#10;5/1 Week1:&#13;&#10;" 
src="Lecture%20note_v3_files/mhtD56D(1).tmp" width=1070 height=960><BR><IMG 
alt="Copper cable: e.g. Cat5(categoies 5 cable), Cat5e, and Cat6&#13;&#10;Fiber cable:contain individual optical fibers, which are tiny tubes made out of glass about the width of a human hair.&#13;&#10;Hubs and switches: the primary devices used to connect computers on a single network, usually referred to as a LAN, or local area network, a physical layer devices.&#13;&#10;Routers: A device that knows how to forward data between independent networks, a networking layer devices&#13;&#10;Routers&#13;&#10;Untitled picture A standard cat six cable has eight wires &#13;&#10;Twisted Pair Cabling and Duplexing&#13;&#10;Duplex communication: The concept that information can flow in both directions across the cable, e.g. phone call.&#13;&#10;Untitled picture Simplex &#10;(Only sends) &#10;Full-duplex &#10;(Simultaneous) &#13;&#10;Simplex communication: The process is unidirectional, e.g monitor&#13;&#10;Physical layer:&#13;&#10;&#13;&#10;Lecture 18: Peer-to-Peer applications&#13;&#10;&#13;&#10;6.4.4 Virtual Local Area Networks (VLANs)&#13;&#10;" src="Lecture%20note_v3_files/mhtD590(1).tmp" 
width=1070 height=760><BR></NOBR></DIV></DIV></DIV>
<DIV>
<P style="MARGIN: 0in">&nbsp;</P>
<P 
style="FONT-SIZE: 9pt; FONT-FAMILY: Arial; COLOR: #969696; DIRECTION: ltr; TEXT-ALIGN: left; MARGIN: 0in">Created 
with OneNote.</P></DIV></BODY></HTML>
